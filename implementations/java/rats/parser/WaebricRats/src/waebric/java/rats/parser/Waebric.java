// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.3,
// (C) 2004-2009 Robert Grimm,
// on Thursday, July 30, 2009 at 5:40:09 PM.
// Edit at your own risk.
// ===========================================================================

package waebric.java.rats.parser;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Action;
import xtc.util.Pair;

import xtc.tree.Node;
import xtc.tree.GNode;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

/**
 * Packrat parser for grammar <code>waebric.java.rats.parser.Waebric</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.3, (C) 2004-2009 Robert Grimm.
 */
public final class Waebric extends ParserBase {

  /** The RESERVED set. */
  public static final Set<String> RESERVED = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fModuleId;
    Result fModuleId$$Plus1;
    Result fKeyword;
    Result fOp;
    Result fIdentifier;
    Result fWord;
    Result fTextChar;
    Result fTextChar$$Plus1;
    Result fTextChar$$Plus2;
    Result fTextChar$$Star1;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fPrimary;
    Result fExpression;
    Result fPair;
    Result fUnaryPredicate;
    Result fArgument;
    Result fMarkup;
    Result fDesignator;
    Result fDesignator$$Star1;
    Result fStatement;
    Result fStatement$$Plus1;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fStatement$$Star1;
    Result fStatement$$Star2;
    Result fStatement$$Plus2;
    Result fFormals;
    Result fFormals$$Plus1;
    Result fMapping;
    Result fPathElement;
    Result fFileName;
    Result fNumber;
    Result fTextTail;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fEmbedding;
    Result fEmbed;
    Result fEmbed$$Plus1;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class WaebricColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public Waebric(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public Waebric(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new WaebricColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.Module.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pModule(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("module")) {
      String v$g$1 = "module";

      yyResult = pModuleId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pModuleElement(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyValue = GNode.create("Module", v$g$1, v$g$2, v$g$3);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$3.
      }
    }

    // Done.
    yyError = yyError.select("module expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.ModuleElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModuleElement(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pImport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("ModuleElement", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pSite(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("ModuleElement", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pFunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("ModuleElement", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.Import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImport(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("import")) {
      String v$g$1 = "import";

      yyResult = pModuleId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("Import", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("import expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.ModuleId.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModuleId(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fModuleId) 
      yyColumn.chunk1.fModuleId = pModuleId$1(yyStart);
    return yyColumn.chunk1.fModuleId;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.ModuleId. */
  private Result pModuleId$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pModuleId$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<String> v$g$1 = yyResult.semanticValue();

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("ModuleId", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("ModuleId", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.ModuleId$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModuleId$$Plus1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fModuleId$$Plus1) 
      yyColumn.chunk1.fModuleId$$Plus1 = pModuleId$$Plus1$1(yyStart);
    return yyColumn.chunk1.fModuleId$$Plus1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.ModuleId$$Plus1. */
  private Result pModuleId$$Plus1$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyBase;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pOp(yyBase);
      if (yyResult.hasValue(".")) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pModuleId$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<String> v$2 = yyResult.semanticValue();

          yyValue = new Pair<String>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new Pair<String>(v$el$1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.Function.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunction(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("def")) {
      String v$g$1 = "def";

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase   = yyChoice1;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue("(")) {

          yyResult = pFormals(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$3 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pOp(yyBase);
            if (yyResult.hasValue(")")) {

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pStatement(yyRepetition1);
                yyError  = yyResult.select(yyError, yyRepetition1);
                if (yyResult.hasValue()) {
                  Node v$el$1 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
                  continue;
                }
                break;
              }
              { // Start scope for v$g$4.
                Pair<Node> v$g$4 = yyRepValue1.reverse();

                yyBase   = yyRepetition1;
                yyResult = pKeyword(yyBase);
                if (yyResult.hasValue("end")) {
                  String v$g$5 = "end";

                  yyValue = GNode.create("Function", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);

                  return yyResult.createValue(yyValue, yyError);
                } else {
                  yyError = yyError.select("'end' expected", yyBase);
                }
              } // End scope for v$g$4.
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }

        // Nested alternative 2.

        yyRepetition1 = yyChoice1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pStatement(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$6.
          Pair<Node> v$g$6 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pKeyword(yyBase);
          if (yyResult.hasValue("end")) {
            String v$g$7 = "end";

            yyValue = GNode.create("Function", v$g$1, v$g$2, v$g$6, v$g$7);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("'end' expected", yyBase);
          }
        } // End scope for v$g$6.
      }
    }

    // Done.
    yyError = yyError.select("function expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Identifiers.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKeyword(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fKeyword) 
      yyColumn.chunk1.fKeyword = pKeyword$1(yyStart);
    return yyColumn.chunk1.fKeyword;
  }

  /** Actually parse waebric.java.rats.parser.Identifiers.Keyword. */
  private Result pKeyword$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Identifiers.Op.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOp(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fOp) yyColumn.chunk1.fOp = pOp$1(yyStart);
    return yyColumn.chunk1.fOp;
  }

  /** Actually parse waebric.java.rats.parser.Identifiers.Op. */
  private Result pOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOpChars(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Identifiers.OpChars.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOpChars(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '#':
        case '$':
        case '&':
        case '(':
        case ')':
        case '+':
        case ',':
        case '.':
        case ':':
        case ';':
        case '=':
        case '?':
        case '@':
        case '[':
        case ']':
        case '{':
        case '|':
        case '}':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("op chars expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Identifiers.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdentifier) 
      yyColumn.chunk1.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.chunk1.fIdentifier;
  }

  /** Actually parse waebric.java.rats.parser.Identifiers.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (!contains(RESERVED, toText(yyValue))) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Identifiers.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWord(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fWord) 
      yyColumn.chunk1.fWord = pWord$1(yyStart);
    return yyColumn.chunk1.fWord;
  }

  /** Actually parse waebric.java.rats.parser.Identifiers.Word. */
  private Result pWord$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWordCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Identifiers.WordCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWordCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char start = (char)yyC;

      if (Character.isLetter(start)) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            char part = (char)yyC;

            if (Character.isLetterOrDigit(part)) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("word characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Strings.String.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pString(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\\':
            {
              final int yyChoice2 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice2);
              if (-1 != yyC) {
                yyIndex = yyChoice2 + 1;

                switch (yyC) {
                case 'n':
                  {
                    yyRepetition1 = yyIndex;
                    continue;
                  }

                case 't':
                  {
                    yyRepetition1 = yyIndex;
                    continue;
                  }

                case '\\':
                  {
                    yyRepetition1 = yyIndex;
                    continue;
                  }

                case '\"':
                  {
                    yyRepetition1 = yyIndex;
                    continue;
                  }

                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;

                      switch (yyC) {
                      case '0':
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                              {
                                yyRepetition1 = yyIndex;
                                continue;
                              }

                            default:
                              /* No match. */
                            }
                          }
                        }
                        break;

                      default:
                        /* No match. */
                      }
                    }
                  }
                  break;

                default:
                  /* No match. */
                }
              }
            }
            break;

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\"':
          case '\\':
            /* No match. */
            break;

          default:
            {
              yyRepetition1 = yyIndex;
              continue;
            }
          }
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('\"' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Text.Text.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pText(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if ('\"' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyValue = "\"\"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      while (true) {

        yyResult = pTextChar(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          continue;
        }
        break;
      }

      if (yyRepeated1) {

        yyC = character(yyRepetition1);
        if ('\"' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("text expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Text.TextChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTextChar(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTextChar) 
      yyColumn.chunk1.fTextChar = pTextChar$1(yyStart);
    return yyColumn.chunk1.fTextChar;
  }

  /** Actually parse waebric.java.rats.parser.Text.TextChar. */
  private Result pTextChar$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '&':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('#' == yyC) {
            yyIndex = yyChoice1 + 1;

            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('x' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyResult = pTextChar$$Plus1(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyC = character(yyResult.index);
                if (';' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }

            // Nested alternative 2.

            yyResult = pTextChar$$Plus2(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyC = character(yyResult.index);
              if (';' == yyC) {
                yyIndex = yyResult.index + 1;

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ((':' == yyC) ||
                (('A' <= yyC) && (yyC <= 'Z')) ||
                ('_' == yyC) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyResult = pTextChar$$Star1(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyC = character(yyResult.index);
                if (';' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }

          // Nested alternative 3.

          yyPredMatched = false;

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            if (('#' == yyC) ||
                (('0' <= yyC) && (yyC <= ':')) ||
                (('A' <= yyC) && (yyC <= 'Z')) ||
                ('_' == yyC) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyPredMatched = true;
            }
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyChoice1, yyError);
          } else {
            yyError = yyError.select("text char expected", yyStart);
          }
        }
        break;

      case '\t':
      case '\n':
      case '\r':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
      case '&':
      case '<':
        /* No match. */
        break;

      default:
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("text char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.TextChar$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTextChar$$Plus1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTextChar$$Plus1) 
      yyColumn.chunk1.fTextChar$$Plus1 = pTextChar$$Plus1$1(yyStart);
    return yyColumn.chunk1.fTextChar$$Plus1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.TextChar$$Plus1. */
  private Result pTextChar$$Plus1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pTextChar$$Plus1(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("text char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.TextChar$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTextChar$$Plus2(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTextChar$$Plus2) 
      yyColumn.chunk1.fTextChar$$Plus2 = pTextChar$$Plus2$1(yyStart);
    return yyColumn.chunk1.fTextChar$$Plus2;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.TextChar$$Plus2. */
  private Result pTextChar$$Plus2$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pTextChar$$Plus2(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("text char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.TextChar$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTextChar$$Star1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTextChar$$Star1) 
      yyColumn.chunk1.fTextChar$$Star1 = pTextChar$$Star1$1(yyStart);
    return yyColumn.chunk1.fTextChar$$Star1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.TextChar$$Star1. */
  private Result pTextChar$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('-' <= yyC) && (yyC <= '.')) ||
          (('0' <= yyC) && (yyC <= ':')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pTextChar$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Literal", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNumber(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Literal", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Literal", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pOp(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pPairs(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$4 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue("}")) {

          yyValue = GNode.create("Literal", v$g$4);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Alternative 5.

    yyResult = pOp(yyStart);
    if (yyResult.hasValue("[")) {

      yyResult = pExpressions(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$5 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = GNode.create("Literal", v$g$5);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Primary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimary(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPrimary) 
      yyColumn.chunk2.fPrimary = pPrimary$1(yyStart);
    return yyColumn.chunk2.fPrimary;
  }

  /** Actually parse waebric.java.rats.parser.Expressions.Primary. */
  private Result pPrimary$1(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pPrimary$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, v$g$3);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Primary$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimary$$Tail1(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    if (yyResult.hasValue(".")) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("Primary", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("primary expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fExpression) 
      yyColumn.chunk2.fExpression = pExpression$1(yyStart);
    return yyColumn.chunk2.fExpression;
  }

  /** Actually parse waebric.java.rats.parser.Expressions.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, v$g$3);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Expression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$$Tail1(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    if (yyResult.hasValue("+")) {

      yyResult = pPrimary(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("Expression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Expressions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressions(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Expressions", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pExpression(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue(",")) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Node> v$g$2 = yyRepValue1.reverse();

      yyResult = pExpression(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("Expressions", v$g$2, v$g$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyValue = GNode.create("Expressions", false);

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Pair.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPair(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPair) 
      yyColumn.chunk2.fPair = pPair$1(yyStart);
    return yyColumn.chunk2.fPair;
  }

  /** Actually parse waebric.java.rats.parser.Expressions.Pair. */
  private Result pPair$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pOp(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("Pair", v$g$1, v$g$2);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Pairs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPairs(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPair(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Pairs", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pPair(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue(",")) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Node> v$g$2 = yyRepValue1.reverse();

      yyResult = pPair(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("Pairs", v$g$2, v$g$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyValue = GNode.create("Pairs", false);

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Predicates.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    if (yyResult.hasValue("list")) {
      yyValue = "list";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIdentifier(yyStart);
    if (yyResult.hasValue("record")) {
      yyValue = "record";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pIdentifier(yyStart);
    if (yyResult.hasValue("string")) {
      yyValue = "string";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Predicates.Predicate.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPredicate(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnaryPredicate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pPredicate$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Action<Node> v$5 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$5, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$6.
        Pair<Action<Node>> v$6 = yyRepValue1.reverse();

        yyValue = apply(v$6, v$g$4);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$6.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Predicate$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPredicate$$Tail1(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '&':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('&' == yyC) {

              yyResult = pUnaryPredicate(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$2 = yyResult.semanticValue();

                yyValue = new Action<Node>() {
                  public Node run(Node v$1) {
                    return GNode.create("Predicate", v$1, v$g$2);
                  }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
        break;

      case '|':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('|' == yyC) {

              yyResult = pUnaryPredicate(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$3 = yyResult.semanticValue();

                yyValue = new Action<Node>() {
                  public Node run(Node v$1) {
                    return GNode.create("Predicate", v$1, v$g$3);
                  }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("predicate expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Predicates.UnaryPredicate.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnaryPredicate(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fUnaryPredicate) 
      yyColumn.chunk2.fUnaryPredicate = pUnaryPredicate$1(yyStart);
    return yyColumn.chunk2.fUnaryPredicate;
  }

  /** Actually parse waebric.java.rats.parser.Predicates.UnaryPredicate. */
  private Result pUnaryPredicate$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pUnaryPredicate(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryPredicate", v$g$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pCondition(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("UnaryPredicate", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary predicate expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Predicates.Condition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCondition(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if ('.' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyResult = pType(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$g$2 = yyResult.semanticValue();

          yyC = character(yyResult.index);
          if ('?' == yyC) {
            yyIndex = yyResult.index + 1;

            yyValue = GNode.create("Condition", v$g$1, v$g$2);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyValue = GNode.create("Condition", v$g$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    yyError = yyError.select("condition expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Markup.Arguments.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArguments(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArgument(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("Arguments", v$g$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pArgument(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue(":")) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Node> v$g$2 = yyRepValue1.reverse();

      yyResult = pArgument(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$3 = yyResult.semanticValue();

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Arguments", v$g$2, v$g$3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyValue = GNode.create("Arguments", false);

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Markup.Argument.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgument(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fArgument) 
      yyColumn.chunk2.fArgument = pArgument$1(yyStart);
    return yyColumn.chunk2.fArgument;
  }

  /** Actually parse waebric.java.rats.parser.Markup.Argument. */
  private Result pArgument$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pOp(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("Argument", v$g$1, v$g$2);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Argument", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Markup.Markup.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMarkup(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fMarkup) 
      yyColumn.chunk2.fMarkup = pMarkup$1(yyStart);
    return yyColumn.chunk2.fMarkup;
  }

  /** Actually parse waebric.java.rats.parser.Markup.Markup. */
  private Result pMarkup$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDesignator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pOp(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pArguments(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pOp(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("Markup", v$g$1, v$g$2);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = GNode.create("Markup", v$g$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Markup.Designator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDesignator(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDesignator) 
      yyColumn.chunk2.fDesignator = pDesignator$1(yyStart);
    return yyColumn.chunk2.fDesignator;
  }

  /** Actually parse waebric.java.rats.parser.Markup.Designator. */
  private Result pDesignator$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyResult = pDesignator$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("Designator", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Designator$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDesignator$$Star1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDesignator$$Star1) 
      yyColumn.chunk2.fDesignator$$Star1 = pDesignator$$Star1$1(yyStart);
    return yyColumn.chunk2.fDesignator$$Star1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.Designator$$Star1. */
  private Result pDesignator$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAttribute(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      yyResult = pDesignator$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Markup.Attribute.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttribute(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    if (yyResult.hasValue("#")) {
      String v$g$1 = "#";

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("Attribute", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pOp(yyStart);
    if (yyResult.hasValue(".")) {
      String v$g$3 = ".";

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("Attribute", v$g$3, v$g$4);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pOp(yyStart);
    if (yyResult.hasValue("$")) {
      String v$g$5 = "$";

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$6 = yyResult.semanticValue();

        yyValue = GNode.create("Attribute", v$g$5, v$g$6);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pOp(yyStart);
    if (yyResult.hasValue(":")) {
      String v$g$7 = ":";

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$8 = yyResult.semanticValue();

        yyValue = GNode.create("Attribute", v$g$7, v$g$8);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 5.

    yyResult = pOp(yyStart);
    if (yyResult.hasValue("@")) {
      String v$g$9 = "@";

      yyResult = pNumber(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$10 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase   = yyChoice1;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue("%")) {
          String v$g$11 = "%";

          yyResult = pNumber(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$g$12 = yyResult.semanticValue();

            yyValue = GNode.create("Attribute", v$g$9, v$g$10, v$g$11, v$g$12);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'%' expected", yyBase);
        }

        // Nested alternative 2.

        yyValue = GNode.create("Attribute", v$g$9, v$g$10);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("attribute expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatement) 
      yyColumn.chunk2.fStatement = pStatement$1(yyStart);
    return yyColumn.chunk2.fStatement;
  }

  /** Actually parse waebric.java.rats.parser.Statements.Statement. */
  private Result pStatement$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("if")) {
      String v$g$1 = "if";

      yyBase   = yyResult.index;
      yyResult = pOp(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pPredicate(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pOp(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pStatement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$3 = yyResult.semanticValue();

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyBase   = yyChoice1;
              yyResult = pKeyword(yyBase);
              if (yyResult.hasValue("else")) {
                String v$g$4 = "else";

                yyResult = pStatement(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$g$5 = yyResult.semanticValue();

                  yyValue = GNode.create("Statement", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("'else' expected", yyBase);
              }

              // Nested alternative 2.

              yyValue = GNode.create("Statement", v$g$1, v$g$2, v$g$3);

              return new SemanticValue(yyValue, yyChoice1, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("each")) {
      String v$g$6 = "each";

      yyBase   = yyResult.index;
      yyResult = pOp(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$g$7 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pOp(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$8 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pOp(yyBase);
              if (yyResult.hasValue(")")) {

                yyResult = pStatement(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$g$9 = yyResult.semanticValue();

                  yyValue = GNode.create("Statement", v$g$6, v$g$7, v$g$8, v$g$9);

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("let")) {
      String v$g$10 = "let";

      yyResult = pStatement$$Plus1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$11 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue("in")) {
          String v$g$12 = "in";

          yyResult = pStatement$$Star1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<Node> v$g$13 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pKeyword(yyBase);
            if (yyResult.hasValue("end")) {
              String v$g$14 = "end";

              yyValue = GNode.create("Statement", v$g$10, v$g$11, v$g$12, v$g$13, v$g$14);

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("'end' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'in' expected", yyBase);
        }
      }
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("comment")) {
      String v$g$15 = "comment";

      yyResult = pString(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$16 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("Statement", v$g$15, v$g$16);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("echo")) {
      String v$g$17 = "echo";

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$18 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("Statement", v$g$17, v$g$18);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }

      // Nested alternative 2.

      yyResult = pEmbedding(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$19 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("Statement", v$g$17, v$g$19);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("cdata")) {
      String v$g$20 = "cdata";

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$21 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("Statement", v$g$20, v$g$21);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("yield")) {
      String v$g$22 = "yield";

      yyBase   = yyResult.index;
      yyResult = pOp(yyBase);
      if (yyResult.hasValue(";")) {

        yyValue = GNode.create("Statement", v$g$22);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 8.

    yyResult = pOp(yyStart);
    if (yyResult.hasValue("{")) {
      String v$g$23 = "{";

      yyResult = pStatement$$Star2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$24 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue("}")) {
          String v$g$25 = "}";

          yyValue = GNode.create("Statement", v$g$23, v$g$24, v$g$25);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Alternative 9.

    yyResult = pDesignator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$26 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pOp(yyBase);
      if (yyResult.hasValue(";")) {

        yyValue = GNode.create("Statement", v$g$26);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 10.

    yyResult = pStatement$$Plus2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$27 = yyResult.semanticValue();

      yyResult = pEnding(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$28 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pOp(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("Statement", v$g$27, v$g$28);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Statement$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement$$Plus1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatement$$Plus1) 
      yyColumn.chunk2.fStatement$$Plus1 = pStatement$$Plus1$1(yyStart);
    return yyColumn.chunk2.fStatement$$Plus1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.Statement$$Plus1. */
  private Result pStatement$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pStatement$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Node>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Statement$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement$$Star1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fStatement$$Star1) 
      yyColumn.chunk3.fStatement$$Star1 = pStatement$$Star1$1(yyStart);
    return yyColumn.chunk3.fStatement$$Star1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.Statement$$Star1. */
  private Result pStatement$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$3 = yyResult.semanticValue();

      yyResult = pStatement$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$4 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$3, v$4);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Statement$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement$$Star2(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fStatement$$Star2) 
      yyColumn.chunk3.fStatement$$Star2 = pStatement$$Star2$1(yyStart);
    return yyColumn.chunk3.fStatement$$Star2;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.Statement$$Star2. */
  private Result pStatement$$Star2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$5 = yyResult.semanticValue();

      yyResult = pStatement$$Star2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$6 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$5, v$6);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Statement$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement$$Plus2(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fStatement$$Plus2) 
      yyColumn.chunk3.fStatement$$Plus2 = pStatement$$Plus2$1(yyStart);
    return yyColumn.chunk3.fStatement$$Plus2;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.Statement$$Plus2. */
  private Result pStatement$$Plus2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMarkup(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$7 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pStatement$$Plus2(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$8 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$7, v$8);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Node>(v$el$7);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Ending.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnding(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEmbedding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Ending", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Ending", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pMarkup(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Ending", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Assignment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pOp(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pOp(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = GNode.create("Assignment", v$g$1, v$g$2);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('(' == yyC) {
        yyIndex = yyChoice1 + 1;
        String v$g$3 = "(";

        yyResult = pFormals(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$4 = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if (')' == yyC) {
            yyIndex = yyResult.index + 1;
            String v$g$5 = ")";

            yyBase = yyIndex;
            yyC    = character(yyBase);
            if ('=' == yyC) {
              yyIndex = yyIndex + 1;
              String v$g$6 = "=";

              yyResult = pStatement(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$7 = yyResult.semanticValue();

                yyValue = GNode.create("Assignment", v$g$1, v$g$3, v$g$4, v$g$5, v$g$6, v$g$7);

                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("'=' expected", yyBase);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Formals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormals(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fFormals) 
      yyColumn.chunk3.fFormals = pFormals$1(yyStart);
    return yyColumn.chunk3.fFormals;
  }

  /** Actually parse waebric.java.rats.parser.Statements.Formals. */
  private Result pFormals$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Formals", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pFormals$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<String> v$g$2 = yyResult.semanticValue();

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("Formals", v$g$2, v$g$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyValue = GNode.create("Formals", false);

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Formals$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormals$$Plus1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fFormals$$Plus1) 
      yyColumn.chunk3.fFormals$$Plus1 = pFormals$$Plus1$1(yyStart);
    return yyColumn.chunk3.fFormals$$Plus1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.Formals$$Plus1. */
  private Result pFormals$$Plus1$1(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyC = character(yyResult.index);
      if (',' == yyC) {
        yyIndex = yyResult.index + 1;

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = pFormals$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<String> v$2 = yyResult.semanticValue();

          yyValue = new Pair<String>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new Pair<String>(v$el$1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("formals expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.Site.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSite(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("site")) {
      String v$g$1 = "site";

      yyResult = pMappings(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue("end")) {
          String v$g$3 = "end";

          yyValue = GNode.create("Site", v$g$1, v$g$2, v$g$3);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'end' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("site expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.Mapping.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMapping(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMapping) 
      yyColumn.chunk3.fMapping = pMapping$1(yyStart);
    return yyColumn.chunk3.fMapping;
  }

  /** Actually parse waebric.java.rats.parser.Sites.Mapping. */
  private Result pMapping$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPath(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pOp(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pMarkup(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("Mapping", v$g$1, v$g$2);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.Mappings.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMappings(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pMapping(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyC = character(yyResult.index);
        if (';' == yyC) {
          yyIndex = yyResult.index + 1;

          yyRepetition1 = yyIndex;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyResult = pMapping(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("Mappings", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pMapping(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Mappings", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyValue = GNode.create("Mappings", false);

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.Path.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPath(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDirName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyC = character(yyResult.index);
      if ('/' == yyC) {
        yyIndex = yyResult.index + 1;

        yyPredMatched = false;

        yyC = character(yyIndex);
        if (-1 != yyC) {
          if ((('\t' <= yyC) && (yyC <= '\n')) ||
              ('\r' == yyC) ||
              (' ' == yyC) ||
              (('.' <= yyC) && (yyC <= '/')) ||
              ('\\' == yyC)) {

            yyPredMatched = true;
          }
        }

        if (! yyPredMatched) {

          yyResult = pFileName(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = difference(yyStart, yyResult.index);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("path expected", yyStart);
        }
      }
    }

    // Alternative 2.

    yyResult = pFileName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("path expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.DirName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDirName(final int yyStart) throws IOException {
    int        yyC;
    Result     yyResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDirectory(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyPredMatched = false;

      yyC = character(yyResult.index);
      if ('/' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("dir name expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.PathElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPathElement(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fPathElement) 
      yyColumn.chunk3.fPathElement = pPathElement$1(yyStart);
    return yyColumn.chunk3.fPathElement;
  }

  /** Actually parse waebric.java.rats.parser.Sites.PathElement. */
  private Result pPathElement$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\t':
      case '\n':
      case '\r':
      case ' ':
      case '.':
      case '/':
      case '\\':
        /* No match. */
        break;

      default:
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pPathElement(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("path element expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.FileExt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFileExt(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;
        if ((('0' <= yyC) && (yyC <= '9')) ||
            (('A' <= yyC) && (yyC <= 'Z')) ||
            (('a' <= yyC) && (yyC <= 'z'))) {

          yyRepetition1 = yyIndex;
          yyRepeated1   = true;
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("file ext expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.Directory.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDirectory(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pPathElement(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('/' == yyC) {
          yyIndex = yyResult.index + 1;

          yyRepetition1 = yyIndex;
          yyRepeated1   = true;
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyResult = pPathElement(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pPathElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("directory expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.FileName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFileName(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fFileName) 
      yyColumn.chunk3.fFileName = pFileName$1(yyStart);
    return yyColumn.chunk3.fFileName;
  }

  /** Actually parse waebric.java.rats.parser.Sites.FileName. */
  private Result pFileName$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPathElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyC = character(yyResult.index);
      if ('.' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pFileExt(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("file name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Layout.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '/':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;

              switch (yyC) {
              case '*':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    final int yyChoice2 = yyRepetition2;

                    // Nested alternative 1.

                    yyC = character(yyChoice2);
                    if (-1 != yyC) {
                      yyIndex = yyChoice2 + 1;

                      switch (yyC) {
                      case '*':
                        {
                          yyPredMatched = false;

                          yyC = character(yyIndex);
                          if ('/' == yyC) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyRepetition2 = yyIndex;
                            continue;
                          } else {
                            yyError = yyError.select("spacing expected", yyStart);
                          }
                        }
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  yyBase = yyRepetition2;
                  yyC    = character(yyBase);
                  if ('*' == yyC) {
                    yyIndex = yyRepetition2 + 1;

                    yyC = character(yyIndex);
                    if ('/' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyRepetition1 = yyIndex;
                      continue;
                    } else {
                      yyError = yyError.select("'*/' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'*/' expected", yyBase);
                  }
                }
                break;

              case '/':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    yyC = character(yyRepetition2);
                    if (-1 != yyC) {
                      yyIndex = yyRepetition2 + 1;

                      switch (yyC) {
                      case '\n':
                      case '\r':
                        /* No match. */
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  yyPredResult = pLineTerminator(yyRepetition2);
                  yyError      = yyPredResult.select(yyError);
                  if (yyPredResult.hasValue()) {

                    yyRepetition1 = yyRepetition2;
                    continue;
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Layout.LineTerminator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineTerminator(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("line terminator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Numbers.Number.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumber(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fNumber) 
      yyColumn.chunk3.fNumber = pNumber$1(yyStart);
    return yyColumn.chunk3.fNumber;
  }

  /** Actually parse waebric.java.rats.parser.Numbers.Number. */
  private Result pNumber$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pNumber(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = difference(yyStart, yyResult.index);

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = difference(yyStart, yyChoice1);

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("number expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Embedding.PreText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreText(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyResult = pTextChar(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('<' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("pre text expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Embedding.PostText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostText(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyResult = pTextChar(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('\"' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("post text expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Embedding.MidText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMidText(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyResult = pTextChar(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('<' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("mid text expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Embedding.TextTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTextTail(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fTextTail) 
      yyColumn.chunk3.fTextTail = pTextTail$1(yyStart);
    return yyColumn.chunk3.fTextTail;
  }

  /** Actually parse waebric.java.rats.parser.Embedding.TextTail. */
  private Result pTextTail$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPostText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("TextTail", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMidText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$2 = yyResult.semanticValue();

      yyResult = pEmbed(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$3 = yyResult.semanticValue();

        yyResult = pTextTail(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$4 = yyResult.semanticValue();

          yyValue = GNode.create("TextTail", v$g$2, v$g$3, v$g$4);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Embedding.Embedding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEmbedding(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fEmbedding) 
      yyColumn.chunk4.fEmbedding = pEmbedding$1(yyStart);
    return yyColumn.chunk4.fEmbedding;
  }

  /** Actually parse waebric.java.rats.parser.Embedding.Embedding. */
  private Result pEmbedding$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPreText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyResult = pEmbed(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyResult = pTextTail(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("Embedding", v$g$1, v$g$2, v$g$3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Embedding.Embed.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEmbed(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fEmbed) 
      yyColumn.chunk4.fEmbed = pEmbed$1(yyStart);
    return yyColumn.chunk4.fEmbed;
  }

  /** Actually parse waebric.java.rats.parser.Embedding.Embed. */
  private Result pEmbed$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Embed", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEmbed$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$2 = yyResult.semanticValue();

      yyResult = pMarkup(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("Embed", v$g$2, v$g$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Embed$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEmbed$$Plus1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fEmbed$$Plus1) 
      yyColumn.chunk4.fEmbed$$Plus1 = pEmbed$$Plus1$1(yyStart);
    return yyColumn.chunk4.fEmbed$$Plus1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.Embed$$Plus1. */
  private Result pEmbed$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMarkup(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pEmbed$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Node>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  static {
    add(RESERVED, new String[] {
      "module",
      "site",
      "import",
      "def",
      "end",
      "if",
      "else",
      "each",
      "echo",
      "comment",
      "let",
      "in",
      "yield",
      "cdata"
    });
  }

  // =========================================================================

  /**
   * Get the specified text.
   *
   * @param s The text.
   * @return The text.
   */
  protected static final String toText(String s) {
    return s;
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
