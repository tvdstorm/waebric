// Todo: Lay down restrictions for grammer e.g. make sure keywords are not used for id_con
//       Should this be done in the parser code???

Package sablecc.waebric;

Helpers
	input_character = [32..126];
	not_star = [input_character - '*'];
	not_star_not_slash = [not_star - '/'];
	letter = ['a'..'z'] | ['A'..'Z'];
	digit = ['0'..'9'];
	minus = '-';
	amp = '\&';
	esc_quote = ('\\' | '\"');	
	str_char = ('\n' | '\t' | '\"' | '\\' | '\' digit digit digit | [input_character - [[10 + 9] + ['"' + '\']]]);
	
	// Used for text
	text_char = [[input_character - [['&' + '"'] + '<']] + [[10 + 13] + 9]];
	text_char_ref = 
		'&#' digit+ ';' |
		'&#x' (digit | letter)+ ';';
		
	text_entity_ref = '&' (letter | '_' | '"') (letter | digit | '.' | '-' | '_' | ':')* ';';

Tokens
	// Keywords
	module = 'module';
	if = 'if';
	else = 'else';
	each = 'each';
	let = 'let';
	def = 'def';
	in = 'in';
	end = 'end';
	comment = 'comment';
	echo = 'echo';
	cdata = 'cdata';
	yield = 'yield';
	import = 'import'; 
	site = 'site';
	list = 'list';
	record = 'record';
	string = 'string';


	// Separators
	l_paren = '(';
	r_paren = ')';
	l_brace = '{';
	r_brace = '}';
	l_bracket = '[';
	r_bracket = ']';
	semi_colon = ';';
	comma = ',';
	dot = '.';
	number_sign = '#';
	dollar_sign = '$';
	at_sign = '@';
	percent_sign = '%';
	question_mark = '?';
	exclam_mark = '!';
	and = '&&';
	or = '||';	
	
	// Operators
	colon = ':';
	assign = '=';
	slash = '/';

	// Comments	
	comments = 
		'/*' (not_star_not_slash not_star* '*'+)* '/' |
		'//' input_character* '\n';
		
	whitespace = (' ' | 13 | 10 | 9)*;
	
	// Identifier
	id_con = letter (letter | digit | minus)*;
	nat_con = digit+;
	symbol_con = ''' [input_character - [[[')' + ' '] + [9 + 10]] + [[13 + ';'] + [',' + '>']]]]*;
	str_con = '"' str_char* '"';
	
	// Miscellaneous
	path_element = ([input_character - [[[' ' + 9] + [13 + 10]] + [['.' + '/'] + '\']]])+;
	file_ext = (letter | digit)+;
	text = '"' (text_char | esc_quote | amp | text_char_ref | text_entity_ref)* '"';
	pre_text = '"' text_char* '<';
	post_text = '>' text_char* '"';
	mid_text = '>' text_char* '<';
				
Ignored Tokens
	comments,
	whitespace;
	
Productions
	// Module definition
	modules = module_declaration*;
	module_declaration = module module_id_declaration module_element_declaration*;
	module_id_declaration = id_con;
	module_element_declaration = 
		{function}	function_declaration | 
		{import}	import_declaration | 
		{site}		site_declaration;
	
	// Imports
	import_declaration = import module_id_declaration;

	// Site
	site_declaration = site mappings_declaration end;
	
	// Mappings
	mappings_declaration = 
		{single}									mapping_declaration |
		{multiple}	mappings_declaration semi_colon mapping_declaration;
	mapping_declaration = path_declaration colon markup_declaration;
	
	// Path & filenames
	path_declaration = 
		{dirname_filename}	dir_name slash file_name |
		{filename}			file_name;
	dir_name = directory;
	directory =
		{single_depth}					path_element |
		{multi_depth}	directory slash path_element;
	file_name = path_element dot file_ext; 

	// Markup	
	markup_declaration = 
		{designator_with_arguments}	designator_declaration arguments_declaration |
		{designator}				designator_declaration;
	
	// Designator
	designator_declaration = id_con attribute_declaration*;
	
	// Attributes
	attribute_declaration =
		{number_sign}		number_sign id_con |
		{dot}				dot id_con |
		{dollar_sign}		dollar_sign id_con |
		{colon}				colon id_con |
		{at_width_height}	at_sign [w]:nat_con percent_sign [h]:nat_con |
		{at_width}			at_sign [w]:nat_con;
	
	// Arguments
	arguments_declaration = l_paren arguments r_paren;
	arguments =
		{single}					argument_declaration |
		{multiple}	arguments comma argument_declaration;
		
	argument_declaration = 
		{argument}						   			   expression_declaration |
		{argument_with_var}		var_declaration assign expression_declaration;
		  
	// Variable
	var_declaration = id_con;

	// Expressions
	expression_declaration =  
		{text}					text |
		{id_con}				id_con |
		{symbol_con}			symbol_con |
		{nat_con}				nat_con |
//		{expression_idcon}		expression_declaration dot id_con |
		{multiple_expressions}	l_bracket expressions r_bracket |
		{key_value_pairs}		l_brace key_value_pairs r_brace;		
		
	expressions = 
		{single}					  expression_declaration |
		{multiple}	expressions comma expression_declaration ;
	
	// Key Value Pairs
	key_value_pairs = 
		{single}						  key_value_pair_declaration |
		{multiple}	key_value_pairs comma key_value_pair_declaration;
	key_value_pair_declaration = id_con colon expression_declaration;
	 
	// Function declaration
	function_declaration = def id_con formals_declaration? statement_declaration* end;
	
	// Formals declaration
	formals_declaration = l_paren formals r_paren;
	formals =
		{single}				  var_declaration |
		{multiple}	formals comma var_declaration;
		
	// Statement declaration
	statement_declaration = 
		{if}				if l_paren predicate r_paren statement_declaration |
		{if_else}			if l_paren predicate r_paren statement_no_short_if_declaration else statement_declaration |
		{each}				each_declaration |
		{let}				let_declaration |
		{function_body}		function_body_declaration |
		{comment}			comment_declaration |
		{echo_expression}	echo_expression_declaration |
		{echo_embedding}	echo_embedding_declaration |
		{cdata}				cdata_declaration |
		{yield}				yield_declaration;		

	statement_no_short_if_declaration = 
		{if_else}			if l_paren predicate r_paren [if_no_short_if]:statement_no_short_if_declaration else [else_no_short_if]:statement_no_short_if_declaration |
		{each}				each_no_short_if_declaration |
		{let}				let_declaration |
		{function_body}		function_body_declaration |
		{comment}			comment_declaration |
		{echo_expression}	echo_expression_declaration |
		{echo_embedding}	echo_embedding_declaration |
		{cdata}				cdata_declaration |
		{yield}				yield_declaration;		

		
	each_declaration = each l_paren var_declaration colon expression_declaration r_paren statement_declaration;
	each_no_short_if_declaration = each l_paren var_declaration colon expression_declaration r_paren statement_no_short_if_declaration;
	
	let_declaration = let assignment_declaration+ in statement_declaration* end;	
	function_body_declaration = l_brace statement_declaration* r_brace;
	comment_declaration = comment str_con semi_colon;
	echo_expression_declaration= echo expression_declaration semi_colon;
	echo_embedding_declaration = echo embedding_declaration semi_colon;
	cdata_declaration = cdata expression_declaration semi_colon;
	yield_declaration = yield semi_colon;

	// Assignment declaration
	assignment_declaration = var_declaration assign expression_declaration semi_colon;
	
	// Predicate declaration
	predicate = 
		{expression}		expression_declaration |
		{expression_type}	expression_declaration dot type_declaration question_mark |
		{not_predicate}		exclam_mark predicate;
//		{and_predicate}		[left_and]:predicate and [right_and]:predicate
//		{or_predicate}		predicate or expression_declaration;

		
	// Type declaration
	type_declaration =
		{list}		list |
		{record}	record |
		{string}	string;
		
	// Embedding declaration
	embedding_declaration = pre_text embed_declaration text_trail_declaration;
	
	// Text trail declaration
	text_trail_declaration =
		{posttext}		post_text |
		{midtext}		mid_text embed_declaration text_trail_declaration;
		
	embed_declaration = 
//		{markup_markup}			markup_declaration* markup_declaration |
		{markup_expression}		markup_declaration* expression_declaration;