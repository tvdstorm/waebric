// Todo: Lay down restrictions for grammer e.g. make sure keywords are not used for id_con
//       Should this be done in the parser code???



Package org.sablecc.grammar.waebric;

Helpers
	all = [0x000 .. 0xffff];
	input_character = [32..127];
	not_star = [input_character - '*'];
	not_star_not_slash = [not_star - '/'];
	letter = ['a'..'z'] | ['A'..'Z'];
	digit = ['0'..'9'];
	minus = '-';
	amp = '\&';
	esc_quote = ('\\' | '\"');	
	str_char = ('\n' | '\t' | '\"' | '\\' | '\' digit digit digit | [input_character - [[10 + 9] + ['"' + '\']]]);
	
	// Used for text
	text_char = [input_character - [['&' + '"'] + '<']];
	text_char_ref = 
		'&#' digit+ ';' |
		'&#x' (digit | letter)+ ';';
		
	text_entity_ref = '&' (letter | '_' | '"') (letter | digit | '.' | '-' | '_' | ':')* ';';
	
States
	normal,
	site;

Tokens
	// Keywords
	module = 'module';
	if = 'if';
	else = 'else';
	each = 'each';
	let = 'let';
	def = 'def';
	in = 'in';
	end = 'end';
	comment = 'comment';
	echo = 'echo';
	cdata = 'cdata';
	yield = 'yield';
	import = 'import'; 
	site = 'site';
	list = 'list';
	record = 'record';
	string = 'string';


	// Separators
	l_paren = '(';
	r_paren = ')';
	l_brace = '{';
	r_brace = '}';
	l_bracket = '[';
	r_bracket = ']';
	semi_colon = ';';
	comma = ',';
	dot = '.';
	number_sign = '#';
	dollar_sign = '$';
	at_sign = '@';
	percent_sign = '%';
	question_mark = '?';
	exclam_mark = '!';
	and = '&&';
	or = '||';	
	
	// Operators
	colon = ':';
	assign = '=';
	slash = '/';
	plus = '+';

	// Comments	
	comments = 
		'/*' (not_star_not_slash not_star* '*'+)* '/' |
		'//' input_character* (13 | 10)+;
		
	whitespace = (' ' | 13 | 10 | 9)*;
	
	// Identifier
	id_con = letter (letter | digit | minus)*;
	nat_con = digit+;
	symbol_con = ''' [input_character - [[[')' + ' '] + [9 + 10]] + [[13 + ';'] + [',' + '>']]]]*;
	str_con = '\"' str_char* '"';
	
	// Miscellaneous
	filename = ([input_character - [[[' ' + 9] + [13 + 10]] + ['.' + '\']]])+ '.' (digit | letter)+;
	text = '"' (text_char | esc_quote | amp | text_char_ref | text_entity_ref)* '"';		
	pre_text = '"' text_char* '<';
	post_text = '>' text_char* '"';
	mid_text = '>' text_char* '<';	
				
Ignored Tokens
	comments,
	whitespace;
	
Productions
	// Module definition
	modules = module_declaration*;
	module_declaration = module module_id_declaration module_element_declaration*;
	module_id_declaration = 
		{single}	id_con | 
		{multiple}	module_id_declaration dot id_con;
	module_element_declaration = 
		{function}	function_declaration | 
		{import}	import_declaration | 
		{site}		site_declaration;
	
	// Imports
	import_declaration = import module_id_declaration;

	// Site
	site_declaration = site mappings_declaration end;
	
	// Mappings
	mappings_declaration = 
		{single}									mapping_declaration |
		{multiple}	mappings_declaration semi_colon mapping_declaration;
	mapping_declaration = filename colon markup_declaration;

	// Markup	
	markup_declaration =
		{designator_with_arguments}	designator_declaration arguments_declaration |
		{designator}				designator_declaration;
	
	markup_no_designator_declaration = 
		{designator_with_arguments}	designator_declaration arguments_declaration;

	// Designator
	designator_declaration = id_con attribute_declaration*;
	
	// Attributes
	attribute_declaration =
		{number_sign}		number_sign id_con |
		{dot}				dot id_con |
		{dollar_sign}		dollar_sign id_con |
		{colon}				colon id_con |
		{at_width_height}	at_sign [w]:nat_con percent_sign [h]:nat_con |
		{at_width}			at_sign [w]:nat_con;
	
	// Arguments
	arguments_declaration = l_paren arguments? r_paren;
	arguments =
		{single}					argument_declaration |
		{multiple}	arguments comma argument_declaration;
		
	argument_declaration = 
		{var_argument}	var_declaration assign expression_declaration |
		{argument}							   expression_declaration;
		  
	// Variable
	var_declaration = id_con;

	// Expressions
	expression_declaration =  
		{text}					text |
		{var}					var_declaration |
		{symbol_con}			symbol_con |
		{nat_con}				nat_con |
		{expression_idcon}		expression_no_var_declaration dot id_con |		
//		{expression_plus}		[left]:expression_no_plus_declaration plus [right]:expression_declaration |
		{multiple_expressions}	l_bracket expressions? r_bracket |
		{key_value_pairs}		l_brace key_value_pairs? r_brace;
		
	expression_no_var_declaration =  
		{text}					text |
		{symbol_con}			symbol_con |
		{nat_con}				nat_con |
		{expression_idcon}		expression_no_var_declaration dot id_con |		
//		{expression_plus}		[left]:expression_no_plus_declaration plus [right]:expression_declaration |
		{multiple_expressions}	l_bracket expressions? r_bracket |
		{key_value_pairs}		l_brace key_value_pairs? r_brace;		
		
/*
	expression_no_plus_declaration =  
		{text}					text |
		{var}					var_declaration |
		{symbol_con}			symbol_con |
		{nat_con}				nat_con |
		{expression_idcon}		expression_declaration dot id_con |		
		{multiple_expressions}	l_bracket expressions? r_bracket |
		{key_value_pairs}		l_brace key_value_pairs? r_brace;
*/		
		
	expressions = 
		{single}					  expression_declaration |
		{multiple}	expressions comma expression_declaration ;
	
	// Key Value Pairs
	key_value_pairs = 
		{single}						  key_value_pair_declaration |
		{multiple}	key_value_pairs comma key_value_pair_declaration;
	key_value_pair_declaration = id_con colon expression_declaration;
	 
	// Function declaration
	function_declaration = def id_con formals_declaration statement_declaration* end;
	
	// Formals declaration
	formals_declaration = 
		{empty}		|
		{available}	l_paren formals? r_paren;
	formals =
		{single}				  var_declaration |
		{multiple}	formals comma var_declaration;
		
	// Statement declaration
	statement_declaration = 
		{statement_no_markup}	statement_no_markup_declaration |
		{markup_statement}		markup_declaration+ statement_no_markup_declaration |
		{markup_single}			markup_declaration semi_colon |
		{markup_multiple}		[multiple]:markup_declaration+ [single]:markup_declaration semi_colon |
		{markup_expression}		markup_declaration+ expression_no_var_declaration semi_colon |
		{embedding}				markup_declaration+ embedding_declaration semi_colon;

	statement_no_markup_declaration =
		{each}				each l_paren var_declaration colon expression_declaration r_paren statement_declaration |
		{let}				let assignment_declaration+ in statement_declaration* end |
		{multiple}			l_brace statement_declaration* r_brace |
		{comment}			comment str_con semi_colon |
		{echo_expression}	echo expression_declaration semi_colon |
		{echo_embedding}	echo embedding_declaration semi_colon |
		{cdata}				cdata expression_declaration semi_colon |
		{yield}				yield semi_colon;
					
	// Assignment declaration
	assignment_declaration = 
		{expression}	var_declaration assign expression_declaration semi_colon |
		{statement}		id_con formals_declaration assign statement_declaration;
	
	// Predicate declaration
	predicate = 
		{expression}		expression_declaration |
		{expression_type}	expression_declaration dot type_declaration question_mark |
		{not_predicate}		exclam_mark predicate |
		{and_predicate}		predicate_no_and_or and predicate |
		{or_predicate}		predicate_no_and_or or expression_declaration;

	predicate_no_and_or =
		{expression}		expression_declaration |
		{expression_type}	expression_declaration dot type_declaration question_mark |
		{not_predicate}		exclam_mark predicate;
		
	// Type declaration
	type_declaration =
		{list}		list |
		{record}	record |
		{string}	string;
		
	// Embedding declaration
	embedding_declaration = pre_text embed_declaration text_tail_declaration;
	
	// Text trail declaration
	text_tail_declaration =
		{posttext}		post_text |
		{midtext}		mid_text embed_declaration text_tail_declaration;
		
	embed_declaration = 
//		{markup_markup}			[multiple]:markup_declaration* [single]:markup_declaration |
		{markup_expression}		markup_declaration* expression_declaration;