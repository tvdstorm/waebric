// Todo: Lay down restrictions for grammer e.g. make sure keywords are not used for id_con
//       Should this be done in the parser code???



Package org.sablecc.grammar.waebric;

Helpers
	all = [0x000 .. 0xffff];
	input_character = [32..127];
	not_star = [input_character - '*'];
	not_star_not_slash = [not_star - '/'];
	letter = ['a'..'z'] | ['A'..'Z'];
	digit = ['0'..'9'];
	minus = '-';
	amp = '\&';
	esc_quote = ('\\' | '\"');	
	str_char = ('\n' | '\t' | '\"' | '\\' | '\' digit digit digit | [input_character - [[10 + 9] + ['"' + '\']]]);
	
	// Used for text
	text_char = [input_character - [['&' + '"'] + '<']];
	text_char_ref = 
		'&#' digit+ ';' |
		'&#x' (digit | letter)+ ';';
		
	text_entity_ref = '&' (letter | '_' | '"') (letter | digit | '.' | '-' | '_' | ':')* ';';
	
States
	normal,
	site;

Tokens
	// Keywords
	module = 'module';
	if = 'if';
	else = 'else';
	each = 'each';
	let = 'let';
	def = 'def';
	in = 'in';
	end = 'end';
	comment = 'comment';
	echo = 'echo';
	cdata = 'cdata';
	yield = 'yield';
	import = 'import'; 
	site = 'site';
	list = 'list';
	record = 'record';
	string = 'string';


	// Separators
	l_paren = '(';
	r_paren = ')';
	l_brace = '{';
	r_brace = '}';
	l_bracket = '[';
	r_bracket = ']';
	semi_colon = ';';
	comma = ',';
	dot = '.';
	number_sign = '#';
	dollar_sign = '$';
	at_sign = '@';
	percent_sign = '%';
	question_mark = '?';
	exclam_mark = '!';
	and = '&&';
	or = '||';	
	
	// Operators
	colon = ':';
	assign = '=';
	slash = '/';
	plus = '+';

	// Comments	
	comments = 
		'/*' (not_star_not_slash not_star* '*'+)* '/' |
		'//' input_character* (13 | 10)+;
		
	whitespace = (' ' | 13 | 10 | 9)*;
	
	// Identifier
	id_con = letter (letter | digit | minus)*;
	nat_con = digit+;
	symbol_con = ''' [input_character - [[[')' + ' '] + [9 + 10]] + [[13 + ';'] + [',' + '>']]]]*;
	str_con = '\"' str_char* '"';
	
	// Miscellaneous
	filename = ([input_character - [[[' ' + 9] + [13 + 10]] + ['.' + '\']]])+ '.' (digit | letter)+;
	text = '"' (text_char | esc_quote | amp | text_char_ref | text_entity_ref)* '"';		
	pre_text = '"' text_char* '<';
	post_text = '>' text_char* '"';
	mid_text = '>' text_char* '<';	
				
Ignored Tokens
	comments,
	whitespace;
	
Productions
	// Module definition
	modules = 
			P.module*
		;
	
	module = 
			T.module P.module_id P.module_element*
		;
	
	module_id = 
			{single}	T.id_con					
		|	{multiple}	P.module_id T.dot T.id_con	
		;

/*
	module_id {-> module_id} = 
			{single}	T.id_con					{-> New module_id.single(id_con)}
		|	{multiple}	P.module_id T.dot T.id_con	{-> New module_id.multiple(module_id, id_con)}
		;
	*/	
	module_element = 
			{function}	P.function	{-> New module_element.function(function)}
		|	{import}	P.import	{-> New module_element.import(import)}
		|	{site}		P.site		{-> New module_element.site(site)}
		;
	
	// Imports
	import = 
			T.import P.module_id
		;

	// Site
	site = 
			T.site P.mappings T.end
		;
	
	// Mappings
	mappings = 
			{single}	P.mapping
		|	{multiple}	P.mappings T.semi_colon P.mapping
		;
		
	mapping = 
			T.filename T.colon P.markup
		;

	// Markup	
	markup =
			{designator_with_args}	P.designator P.arguments 
		|	{designator}			P.designator
		;
	
	markup_no_designator = 
			{designator_with_args}	P.designator P.arguments
		;

	// Designator
	designator = 
			T.id_con P.attribute*
		;
	
	// Attributes
	attribute =
			{number_sign}		T.number_sign T.id_con 
		|	{dot}				T.dot T.id_con 
		|	{dollar_sign}		T.dollar_sign T.id_con 
		|	{colon}				T.colon T.id_con 
		|	{at_width_height}	T.at_sign [w]:T.nat_con T.percent_sign [h]:T.nat_con 
		|	{at_width}			T.at_sign [w]:T.nat_con
		;
	
	// Arguments
	arguments = 
			T.l_paren P.argument_list? T.r_paren
		;
		
	argument_list =
			{single}	P.argument 
		|	{multiple}	P.argument_list T.comma P.argument
		;
		
	argument = 
			{assign}	T.id_con T.assign P.expression 
		|	{argument}	P.expression
		;
		  
	// Expressions
	expression =  
			{text}					T.text 
		|	{idcon}					T.id_con 
		|	{symbol_con}			T.symbol_con 
		|	{nat_con}				T.nat_con 
		|	{expression_idcon}		P.expression_no_idcon T.dot T.id_con 
		|	{multiple_expressions}	T.l_bracket P.expressions? T.r_bracket 
		|	{key_value_pairs}		T.l_brace P.key_value_pairs? T.r_brace
		;
		
	expression_no_idcon =  
			{text}					T.text 
		|	{symbol_con}			T.symbol_con 
		|	{nat_con}				T.nat_con 
		|	{expression_idcon}		P.expression_no_idcon T.dot T.id_con 
		|	{multiple_expressions}	T.l_bracket P.expressions? T.r_bracket 
		|	{key_value_pairs}		T.l_brace P.key_value_pairs? T.r_brace
		;		
		
	expressions = 
			{single}	P.expression 
		|	{multiple}	P.expressions T.comma P.expression
		;
	
	// Key Value Pairs
	key_value_pairs = 
			{single}	P.key_value_pair 
		|	{multiple}	P.key_value_pairs T.comma P.key_value_pair
		;
		
	key_value_pair = 
			T.id_con T.colon P.expression
		;
	 
	// Function
	function {-> module_element} = 
			T.def T.id_con P.formals P.statement* T.end
		;
	
	// Formals
	formals = 
			{empty}		
		|	{available}	T.l_paren P.formal? T.r_paren
		;
		
	formal =
			{single}	T.id_con 
		|	{multiple}	P.formal T.comma T.id_con
		;
		
	// Statement
	statement = 
			{statement_no_markup}	P.statement_no_markup
		|	{markup_statement}		P.markup+ P.statement_no_markup
		|	{markup_single}			P.markup T.semi_colon
		|	{markup_multiple}		[multiple]:P.markup+ [single]:P.markup T.semi_colon
		|	{markup_expression}		P.markup+ P.expression_no_idcon T.semi_colon
		|	{embedding}				P.markup+ P.embedding T.semi_colon
		;

	statement_no_markup =
			{each}				T.each T.l_paren T.id_con T.colon P.expression T.r_paren P.statement
		|	{let}				T.let P.assignment+ T.in P.statement* T.end
		|	{multiple}			T.l_brace P.statement* T.r_brace
		|	{comment}			T.comment T.str_con T.semi_colon
		|	{echo_expression}	T.echo P.expression T.semi_colon
		|	{echo_embedding}	T.echo P.embedding T.semi_colon
		|	{cdata}				T.cdata P.expression T.semi_colon
		|	{yield}				T.yield T.semi_colon
		;
					
	// Assignment
	assignment = 
			{expression}	T.id_con T.assign P.expression T.semi_colon
		|	{statement}		T.id_con P.formals T.assign P.statement
		;
	
	// Predicate
	predicate = 
			{expression}		P.expression
		|	{expression_type}	P.expression T.dot P.type T.question_mark
		|	{not_predicate}		T.exclam_mark P.predicate
		|	{and_predicate}		P.predicate_no_and_or T.and P.predicate
		|	{or_predicate}		P.predicate_no_and_or T.or P.expression
		;

	predicate_no_and_or =
			{expression}		P.expression
		|	{expression_type}	P.expression T.dot P.type T.question_mark
		|	{not_predicate}		T.exclam_mark P.predicate
		;
		
	// Type
	type =
			{list}		T.list
		|	{record}	T.record
		|	{string}	T.string
		;
		
	// Embedding
	embedding = 
			T.pre_text P.embed P.text_tail
		;
	
	// Text trail
	text_tail =
			{posttext}	T.post_text
		|	{midtext}	T.mid_text P.embed P.text_tail
		;
		
	embed = 
//			{markup_markup}			[multiple]:P.markup* [single]:P.markup
	/*|*/	{markup_expression}		P.markup* P.expression
		;
		
Abstract Syntax Tree

	modules =
			module*
		;
		
	module_element =
			{function}	function
		|	{import}	import
		|	{site}		site
		;