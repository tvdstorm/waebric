//TODO: Fix Expression: id_con dot id_con

Package org.sablecc.grammar.waebric;

Helpers
	tab = 09; 
	cr = 13;
	lf = 10;
	space = ' ';

	all = [0x000 .. 0xffff];
	input_character = [32..127];
	not_star = [all - '*'];
	not_star_not_slash = [not_star - '/'];
	letter = ['a'..'z'] | ['A'..'Z'];
	digit = ['0'..'9'];
	minus = '-';
	amp = '&';
	esc_quote = ('\\' | '\"');	
	str_char = ('\n' | '\t' | '\"' | '\\' | '\' digit digit digit | [[32..255] - ['"' + '\']]);
	
	
	// Used for text
	basic_text_char = [[input_character + [[tab + cr] + lf]] - ['"' + '<']];
	text_char_ref = 
		'&#' digit+ ';' |
		'&#x' (digit | letter)+ ';';
		
	text_entity_ref = '&' (letter | '_' | '"') (letter | digit | '.' | '-' | '_' | ':')* ';';
	
	text_char = (basic_text_char | esc_quote | amp | text_char_ref | text_entity_ref);
	
States
	normal,
	comment;
	
Tokens
	// Keywords
	module = 'module';
	if = 'if';
	else = 'else';
	each = 'each';
	let = 'let';
	def = 'def';
	in = 'in';
	end = 'end';
	{normal->comment}	comment = 'comment';
	echo = 'echo';
	cdata = 'cdata';
	yield = 'yield';
	import = 'import'; 
	site = 'site';
	list = 'list';
	record = 'record';
	string = 'string';
		
		
	// Separators
	l_paren = '(';
	r_paren = ')';
	l_brace = '{';
	r_brace = '}';
	l_bracket = '[';
	r_bracket = ']';
	semi_colon = ';';
	comma = ',';
	dot = '.';
	number_sign = '#';
	dollar_sign = '$';
	at_sign = '@';
	percent_sign = '%';
	question_mark = '?';
	exclam_mark = '!';
	and = '&&';
	or = '||';	
	
	// Operators
	colon = ':';
	assign = '=';
	slash = '/';
	plus = '+';

	// Comments	
	comments = 
		'/*' (not_star_not_slash not_star* '*'+)* '/' |
		'//' input_character* (lf | cr)+;
		
	whitespace = (space | cr | lf | tab)*;
	
	// Identifier
	id_con = letter (letter | digit | minus )*;
	nat_con = digit+;
	symbol_con = ''' [input_character - [[[')' + space] + [tab + cr]] + [[lf + ';'] + [',' + '>']]]]*;
	
	{comment->normal}	str_con = '"' str_char* '"';
		
	// Miscellaneous
	filename = '[' ([input_character - [[[space + tab] + [lf + cr]] + ['.' + '\']]])+ '.' (digit | letter)+ ']';
	text = '"' text_char* '"';
	pre_text = '"' text_char* '<';
	post_text = '>' text_char* '"';
	mid_text = '>' text_char* '<';
				
Ignored Tokens
	comments,
	whitespace;
	
Productions
	// Module definition
	modules = 
			P.module*
		;
	
	module = 
			T.module P.module_id P.module_element*
		;
	
	module_id  = 
			{single}	T.id_con
		|	{multiple}	P.module_id T.dot T.id_con
		;

	module_element = 
			{function}	P.function
		|	{import}	P.import
		|	{site}		P.site
		;
	
	// Imports
	import = 
			T.import P.module_id
		;

	// Site
	site = 
			T.site P.mappings T.end
		;
	
	// Mappings
	mappings = 
			{single}	P.mapping
		|	{multiple}	P.mappings T.semi_colon P.mapping
		;
		
	mapping = 
			T.filename T.colon P.markup
		;

	// Markup	
	markup =
			{designator_with_args}	P.designator P.arguments 
		|	{designator}			P.designator
		;
	
	// Designator
	designator = 
			T.id_con P.attribute*
		;
	
	// Attributes
	attribute =
			{number_sign}		T.number_sign T.id_con 
		|	{dot}				T.dot T.id_con 
		|	{dollar_sign}		T.dollar_sign T.id_con 
		|	{colon}				T.colon T.id_con 
		|	{at_width_height}	T.at_sign [w]:T.nat_con T.percent_sign [h]:T.nat_con 
		|	{at_width}			T.at_sign [w]:T.nat_con
		;
	
	// Arguments
	arguments = 
			T.l_paren P.argument_list? T.r_paren
		;
		
	argument_list =
			{single}	P.argument 
		|	{multiple}	P.argument_list T.comma P.argument
		;
		
	argument = 
			{assign}	T.id_con T.assign P.expression 
		|	{argument}	P.expression
		;
		  
	// Expressions
	expression =  
			{text}					T.text 
		|	{idcon}					T.id_con 
		|	{symbol_con}			T.symbol_con 
		|	{nat_con}				T.nat_con 
		|	{expression_idcon}		P.expression_no_idcon T.dot T.id_con 
		|	{multiple_expressions}	T.l_bracket P.expressions? T.r_bracket 
		|	{key_value_pairs}		T.l_brace P.key_value_pairs? T.r_brace
		;
		
	expression_no_idcon =  
			{text}					T.text 
		|	{symbol_con}			T.symbol_con 
		|	{nat_con}				T.nat_con 
		|	{expression_idcon}		P.expression_no_idcon T.dot T.id_con 
		|	{multiple_expressions}	T.l_bracket P.expressions? T.r_bracket 
		|	{key_value_pairs}		T.l_brace P.key_value_pairs? T.r_brace
		;		
		
	expressions = 
			{single}	P.expression 
		|	{multiple}	P.expressions T.comma P.expression
		;
	
	// Key Value Pairs
	key_value_pairs = 
			{single}	P.key_value_pair 
		|	{multiple}	P.key_value_pairs T.comma P.key_value_pair
		;
		
	key_value_pair = 
			T.id_con T.colon P.expression
		;
	 
	// Function
	function = 
			T.def T.id_con P.formals? P.statement* T.end
		;
	
	formals = 
			T.l_paren P.formal? T.r_paren
		;
		
	formal =
			{single}	T.id_con 
		|	{multiple}	P.formal T.comma T.id_con
		;
		
	// Statement
	statement = 
			{no_markup}				P.statement_no_markup
		|	{markup_statement}		P.markup+ P.statement_no_markup
		|	{markup_single}			P.markup T.semi_colon
		|	{markup_multiple}		[multiple]:P.markup+ [single]:P.markup T.semi_colon
		|	{markup_expression}		P.markup+ P.expression_no_idcon T.semi_colon
		|	{embedding}				P.markup+ P.embedding T.semi_colon
		|	{if_then}				T.if T.l_paren P.predicate T.r_paren P.statement
		|	{if_then_else}			T.if T.l_paren P.predicate T.r_paren [thenbranch]:P.statement_no_short_if T.else [elsebranch]:P.statement
		;
		
	statement_no_short_if = 
			{no_markup}				P.statement_no_markup
		|	{markup_statement}		P.markup+ P.statement_no_markup
		|	{markup_single}			P.markup T.semi_colon
		|	{markup_multiple}		[multiple]:P.markup+ [single]:P.markup T.semi_colon
		|	{markup_expression}		P.markup+ P.expression_no_idcon T.semi_colon
		|	{embedding}				P.markup+ P.embedding T.semi_colon
		|	{if_then_else}			T.if T.l_paren P.predicate T.r_paren [thenbranch]:P.statement_no_short_if T.else [elsebranch]:P.statement_no_short_if
		;
	

	statement_no_markup =
			{each}				T.each T.l_paren T.id_con T.colon P.expression T.r_paren P.statement
		|	{let}				T.let P.assignment+ T.in P.statement* T.end
		|	{multiple}			T.l_brace P.statement* T.r_brace
		|	{comment}			T.comment T.str_con T.semi_colon
		|	{echo_expression}	T.echo P.expression T.semi_colon
		|	{echo_embedding}	T.echo P.embedding T.semi_colon
		|	{cdata}				T.cdata P.expression T.semi_colon
		|	{yield}				T.yield T.semi_colon
		;
				
	// Assignment
	assignment = 
			{expression}	T.id_con T.assign P.expression T.semi_colon
		|	{statement}		T.id_con P.formals T.assign P.statement
		;
	
	// Predicate
	predicate = 
			{expression}		P.expression
		|	{expression_type}	P.expression T.colon P.type T.question_mark
		|	{not_predicate}		T.exclam_mark P.predicate_no_and_or
		|	{and_predicate}		P.predicate_no_and_or T.and P.predicate
		|	{or_predicate}		P.predicate_no_and_or T.or P.expression
		;

	predicate_no_and_or =
			{expression}		P.expression
		|	{expression_type}	P.expression T.colon P.type T.question_mark
		|	{not_predicate}		T.exclam_mark P.predicate_no_and_or
		;
		
	// Type
	type =
			{list}		T.list
		|	{record}	T.record
		|	{string}	T.string
		;
		
	// Embedding
	embedding = 
			T.pre_text P.embed P.text_tail
		;
	
	// Text trail
	text_tail =
			{posttext}	T.post_text
		|	{midtext}	T.mid_text P.embed P.text_tail
		;
		
	embed = 
			{markup_markup}			[multiple]:P.markup* [single]:P.markup
		|	{markup_expression}		P.markup* P.expression
		;