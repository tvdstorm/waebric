importPackage(java.io)

load("lib.js")
load("ometa-base.js")
load("parser.js")
load("bs-js-compiler.js")
load("bs-ometa-compiler.js")
load("bs-ometa-optimizer.js")
load("bs-ometa-js-compiler.js")

load("../classes/Module.js")
load("../classes/ModuleId.js")
load("../classes/Import.js")
load("../classes/Site.js")
load("../classes/Mapping.js")
load("../classes/FunctionDefinition.js")
load("../classes/Statement.js")
load("../classes/Designator.js")
load("../classes/Attribute.js")
load("../classes/Argument.js")
load("../classes/Markup.js")
load("../classes/Embed.js")
load("../classes/Embedding.js")
load("../classes/Expression.js")
load("../classes/KeyValuePair.js")
load("../classes/Predicate.js")
load("../classes/TextTail.js")
load("../classes/Type.js")
load("../classes/Assignment.js")
load("../checker/WaebricSemanticException.js")
load("../checker/WaebricSemanticValidator.js")
load("../checker/WaebricSemanticCollector.js")
load("../checker/XHTML.js")
load("../checker/WaebricSemanticVisitor.js")
load("../checker/Environment.js")

/**
 * Returns the Waebric grammar written in OMeta for parsing
 *
 * @return Waebric parser (String)
 */
function loadWaebricParser(){
    var fis = new FileInputStream('../parser.ometa');
    var bis = new BufferedInputStream(fis);
    var dis = new DataInputStream(bis);
    
    var parser = '';
    while (dis.available() != 0) {
        parser += dis.readLine() + '\n';
    }
    fis.close();
    bis.close();
    dis.close();
    return parser;
}

/**
 * Returns the Waebric grammar written in OMeta for interpreting
 *
 * @return Waebric interpreter (String)
 */
function loadWaebricInterpreter(){
    var fis = new FileInputStream('../interpreter.ometa');
    var bis = new BufferedInputStream(fis);
    var dis = new DataInputStream(bis);
    
    var interpreter = '';
    while (dis.available() != 0) {
        interpreter += dis.readLine() + '\n';
    }
    fis.close();
    bis.close();
    dis.close();
    return interpreter;
}

/**
 * Returns a waebric program without dependencies
 *
 * @return Waebric program (String)
 */
function loadWaebricProgram(path){
    try {
        var fis = new FileInputStream(path);
        var bis = new BufferedInputStream(fis);
        var dis = new DataInputStream(bis);
        
        var program = '';
        while (dis.available() != 0) {
            program += dis.readLine() + '\n';
        }
        fis.close();
        bis.close();
        dis.close();
        return program;
    } catch (exception) {
        throw new NonExistingModuleException(path);
    }
}

/**
 * Parse and interprete the waebric program
 * First, the Abstract Syntax Tree is generated by the Waebric parser as a String.
 * Then, the Abstract Syntax Tree is converted to a data object by the interpreter
 *
 * @return Output of the Waebric parser (AST)
 * @return Output of the Waebric interpreter (DATA OBJECT)
 */
function translateCode(source){
    var translationError = function(m, i){
        alert("Translation error - please tell Alex about this!");
        throw fail
    }, tree = BSOMetaJSParser.matchAll(source, "topLevel", undefined, function(m, i){
        throw fail.delegated({
            errorPos: i
        })
    })
    return BSOMetaJSTranslator.match(tree, "trans", undefined, translationError)
}

/**
 * Evaluates the program and returns the data object
 * @param {Object} path
 */
function evaluateProgram(path){
    try {
        //Load the program source from the filesystem
        var programSource = loadWaebricProgram(path);
		
        //Load the parser source from the filesystem
        var parserSource = loadWaebricParser();
        
        //Build parser with OMeta
        var parser = eval(translateCode(parserSource));
        
        //Parse the Waebric program with OMeta
        var tree = parser.matchAll(programSource, "Module");
		//print("==================================================================")
		//print(tree);
		//print("==================================================================")
        
        //Load the interpreter source from the filesystem
        var interpreterSource = loadWaebricInterpreter();
        
        //Build the interpreter with OMeta
        var interpreter = eval(translateCode(interpreterSource));
        
        //Interprete the parse tree of the Waebric program
        var module = interpreter.match(tree, "interp");
		
		//Determine path of root program needed for finding dependencies in filesystem          
        var arrPath = path.split('/');
        var directory = arrPath.slice(0, arrPath.length - 1).join('/').concat('/');
		
		//Load dependencies	
        module.dependencies = loadDependencies(directory, module);   
		
		//Return module
		return module     
    } catch (exception) {
        throw exception;
    }
}

/**
 * Loads all transitive dependencies per module
 *
 * @param {Module} module
 */
function loadDependencies(directory, module){
    var dependencies = new Array();
    for (var i = 0; i < module.imports.length; i++) {
        var path = directory + module.imports[i].moduleId.identifier + '.wae';
        try {
            var dependency = evaluateProgram(path)
            dependencies.push(dependency)
        } catch (exception) {
            print(exception);
        }
    }
    return dependencies;
}

try {
	
}catch(exception if exception instanceof NonExistingModuleException){
	print('Root module not found on file system. Evaluation terminated');
}catch(exception){
	print(exception);
}

//Evaluate
var module = evaluateProgram('../program.wae');

//Perform semantic validation
//var validator = new WaebricSemanticValidator();
//var exceptions = WaebricSemanticValidator.validateAll(module);
//print(exceptions)
var root = new Environment(null);
module.accept(new ModuleVisitor(), root);
//print(root.functions);
//print(root.variables);
print(root.getExceptions());
