%package "waebric";
%import "waebric.ast.*";
%class "WaebricParser";


%terminals MODULE, IMPORT, DEF, END, SITE, LIST, RECORD, STRING, IF, ELSE, COMMENT, ECHO, CDATA, EACH, LET, IN, YIELD, IDCON;

%terminals LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK;

%terminals SEMICOLON, COMMA, DOT, COLON, MOD, ADDCHAR, DIV, QUESTION, NOT, ANDAND, OROR, EQ ;

%terminals DIRNAME, FILENAME;

%terminals NATCON, STRCON, SYMBOLCON;


%terminals PRETEXT, MIDTEXT, POSTTEXT, TEXT;

%terminals IDCONTAIL;

%terminals IDCONDESIGNATOR;

%terminals HASHIDCON;

%terminals ATTDOTIDCON, ATTDOLLARIDCON, ATTCOLONIDCON, ADDCHARNATCON;

%goal module;

/* SDF specificatie: languages/waebric/syntax/Modules */
module = MODULE moduleid.i moduleelements_opt.e {: //@module(i,[e]) :}
;

moduleid = idcons.i  {: //@module-id([$i]) :}
;



idcons = IDCON.i {: //$idconsa($i) :}
| idcons.a DOT IDCON.b {: //$idconslist(a,$b) :}
;

moduleelements_opt =
| moduleelements
;

moduleelements = moduleelement
| moduleelements moduleelement 
;

moduleelement = functiondef
| import
| site
;

import = IMPORT moduleid.m {: //@import(m) :}
;

/* SDF specificatie: languages/waebric/syntax/Functions */
functiondef = DEF IDCON.i formals.f statements_opt.s END {: //@def($i,f,s) :}
;

/* SDF specificatie: languages/waebric/syntax/Statements */
statements_opt = {: //[]empty_statementlist() :}
| statements.s {://[]statementlist(s):}
;

statements = statement
| statements.s statement.t {: //$statements(s,t):} 
| markupstatement
| statements.s markupstatement.t {: //$statements(s,t):}
;

statement = EACH LPAREN IDCON COLON expression RPAREN statement
| LET assignments IN statements_opt END 
| LBRACE statements_opt.s RBRACE {: //@block(s) :}
;

statement = matched_statement
| open_statement
;

matched_statement = IF LPAREN predicate.p RPAREN matched_statement.a ELSE matched_statement.b {: //@if-else(p,a,b) :}
| COMMENT STRCON.s SEMICOLON {: //@comment($s) :}
| ECHO expression.e SEMICOLON {: //@echo(e) :}
| ECHO embedding.e SEMICOLON {: //@echo-embedding(e) :}
| CDATA expression.e SEMICOLON {: //@cdata(e) :}
| YIELD SEMICOLON {: //@yield() :}
;

open_statement = IF LPAREN predicate.p RPAREN statement.a {: //@if(p,a) :}
| IF LPAREN predicate.p RPAREN matched_statement.a ELSE open_statement.b {: //@if-else(p,a,b) :}
;


assignment = IDCON formals EQ statement
;

assignments = assignment
| assignments assignment
;

formals = {://@empty() :}
| LPAREN formallist.f RPAREN {://@formals([$f]) :}
;

formallist = IDCON.i {: //$formal_a($i):}
| idcons.a COMMA IDCON.b {: //$formallist(a,$b):}
;



/* SDF specificatie: languages/waebric/syntax/Expressions */

/*
%left expression_cat
Expressions.sdf:  Expression "+" Expression -> Expression {cons("cat"), left}
*/
var = IDCON.i {: //@var($i) :}
;

expression = var
| symbolcon.s {: //@sym(s) :}
| NATCON.n {: //@num(#n) :}
| textexpression.t {: //@text(t) :}  
| expression.e DOT IDCON.i {: //@field(e,$i) :}
| LBRACK expressions.e RBRACK {: //@list([e]) :}
| LBRACE keyvaluepairs.party RBRACE  {: //@record([party]) :}
;

embedexpression = IDCONTAIL.i {: //@var($i) :}
| symbolcon.s {: //@sym(s) :}
| NATCON.n {: //@num(#n) :}  
| expression.e DOT IDCONTAIL.i {: //@field(e,$i) :}
| LBRACK expressions.e RBRACK {: //@list([e]) :}
| LBRACE keyvaluepairs.p RBRACE  {: //@record([p]) :} 
;

textexpression = TEXT.t {: //$text_expression($t) :}
;

symbolcon = SYMBOLCON.s  {: //$sym_text($s) :}
;

expressions = expression
| expression COMMA expressions 
;

keyvaluepair = IDCONDESIGNATOR.i COLON expression.e  {: //@pair($i,e) :} 
;

keyvaluepairs = keyvaluepair
| keyvaluepairs COMMA keyvaluepair
;

/* SDF specificatie: languages/waebric/syntax/Embedding */


texttail = POSTTEXT.p {: //@post($p) :}
| MIDTEXT.m embed.e texttail.t {: //@mid($m,e,t) :}
;

embedding = PRETEXT.p embed.e texttail.t  {: //@pre($p,e,t) :}
;

embed = markup_opt.m embedexpression.e {: //@exp-embedding([m],e) :}
;


markup_opt= 
|embed_markup_seq
;

embed_markup_seq = markup
| embed_markup_seq markup
;

markup_seq = markup
| markup_seq.m markup.n {: //[]markup_seq(m,n) :}
;

/* SDF specificatie: languages/waebric/syntax/Markup */

arguments = LPAREN argumentlist_opt.a RPAREN {: //@args(a) :}
;

argumentlist = argument.a
| argument.a COMMA argumentlist.b
;

argumentlist_opt = {: //[]emptyarglist() :}
| argumentlist.a {: //[]arglist(a) :}
;

argument = IDCON.i EQ expression.e {: //@attr($i,e) :}
| expression
;

markup = designator.d arguments.a {: //@call(d,a) :}
| designator.d
;

designator = IDCONDESIGNATOR.i attribute_opt.a {: //@tag($i,[a]) :}
;

markup_seqlist = markup_seq.s {: //[]markup_seqlist(s) :}
;

markupstatement = markup_seq.m statement.s {: //@markup-stat(m,s) :}
| markup.m SEMICOLON {: //@markup(m) :}
| markup_seq.s markup.m SEMICOLON {: //@markup-markup(s,m) :}
| markup_seqlist.s expression.e SEMICOLON {: //@markup-exp(s,e) :}
| markup_seqlist.s embedding.e SEMICOLON {: //@markup-embedding(s,e) :}
;

attribute = HASHIDCON.i {: //$id($i) :}
| ATTDOTIDCON.i {: //$class($i) :}
| ATTDOLLARIDCON.i {: //$name($i) :}
| ATTCOLONIDCON.i {: //$type($i) :}
| ADDCHAR NATCON.w MOD NATCON.h	{: //#with-height(#w,#h) :}
| ADDCHARNATCON.w {: //#height(#w) :}  
;

attribute_opt =
| attributes        
;

attributes = attribute 
| attribute attributes 
;




/* SDF specificatie: languages/waebric/syntax/Sites */
site = SITE mappings_opt.m END {: //@site([m]) :}
;

mappings_opt = 
| mappings
;

mappings = mapping
| mappings SEMICOLON mapping
;

mapping = path.p COLON markup.m {: //@mapping(p,m) :}
;

path = DIRNAME.d DIV FILENAME.f {: //@path($d,$f) :}
| FILENAME.f  {: //$filenamestring($f) :}
;

/* SDF specificatie: languages/waebric/syntax/Predicates */

type = LIST {: //@list-type() :}
| RECORD {: //@record-type() :} 
| STRING {: //@string-type() :}
;

/* some predicates LEFTassociative %left
%left predicate_and
%left predicate_or
Predicates.sdf:  {left:
Predicates.sdf:   Predicate "&&" Predicate -> Predicate {cons("and"), left}
Predicates.sdf:   Predicate "||" Predicate -> Predicate {cons("or"), left}
*/

simplepredicate = expression
| expression.e DOT type.t QUESTION {: //@is-a(e,t) :}
| NOT simplepredicate.p {: //@not(p) :}
;

conjunction = predicate.p ANDAND simplepredicate.q {: //@and(p,q) :}
;

predicate = simplepredicate
| conjunction
| predicate.p OROR simplepredicate.q {: //@or(p,q) :}
;


