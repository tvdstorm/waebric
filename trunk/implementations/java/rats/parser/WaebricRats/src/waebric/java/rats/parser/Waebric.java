// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.3,
// (C) 2004-2009 Robert Grimm,
// on Friday, July 31, 2009 at 2:46:14 PM.
// Edit at your own risk.
// ===========================================================================

package waebric.java.rats.parser;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Action;
import xtc.util.Pair;

import xtc.tree.Node;
import xtc.tree.GNode;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

/**
 * Packrat parser for grammar <code>waebric.java.rats.parser.Waebric</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.3, (C) 2004-2009 Robert Grimm.
 */
public final class Waebric extends ParserBase {

  /** The RESERVED set. */
  public static final Set<String> RESERVED = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fModuleId;
    Result fModuleId$$Star1;
    Result fFunction;
    Result fFunction$$Star1;
    Result fFunction$$Star2;
    Result fSym;
    Result fIdentifier;
    Result fWord;
    Result fEscapeSequence;
    Result fTextChar;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fTextChar$$Plus1;
    Result fTextChar$$Plus2;
    Result fTextChar$$Star1;
    Result fExpression;
    Result fPostfix;
    Result fPair;
    Result fUnary;
    Result fArgument;
    Result fMarkup;
    Result fStatement;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fFormals;
    Result fFormals$$Star1;
    Result fSite;
    Result fMapping;
    Result fElt;
    Result fNumber;
    Result fTextTail;
    Result fEmbed;
    Result fEmbed$$Plus1;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class WaebricColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public Waebric(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public Waebric(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new WaebricColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.Module.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pModule(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("module")) {

      yyResult = pModuleId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pModuleElement(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$2.
          Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.create("Module", v$g$1, v$g$2);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("module expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.TestExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pTestExpression(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("TestExpression", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.TestStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pTestStatement(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("TestStatement", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.TestSite.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pTestSite(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSite(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("TestSite", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.TestFunction.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pTestFunction(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("TestFunction", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.ModuleElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModuleElement(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pImport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("ModuleElement", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pSite(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("ModuleElement", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pFunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("ModuleElement", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.Import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImport(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("import")) {

      yyResult = pModuleId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("Import", v$g$1);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("import expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.ModuleId.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModuleId(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fModuleId) 
      yyColumn.chunk1.fModuleId = pModuleId$1(yyStart);
    return yyColumn.chunk1.fModuleId;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.ModuleId. */
  private Result pModuleId$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyResult = pModuleId$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("ModuleId", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.ModuleId$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModuleId$$Star1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fModuleId$$Star1) 
      yyColumn.chunk1.fModuleId$$Star1 = pModuleId$$Star1$1(yyStart);
    return yyColumn.chunk1.fModuleId$$Star1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.ModuleId$$Star1. */
  private Result pModuleId$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue(".")) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyResult = pModuleId$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<String> v$2 = yyResult.semanticValue();

          yyValue = new Pair<String>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Waebric.Function.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunction(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fFunction) 
      yyColumn.chunk1.fFunction = pFunction$1(yyStart);
    return yyColumn.chunk1.fFunction;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.Function. */
  private Result pFunction$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("def")) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase   = yyChoice1;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue("(")) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pFormals(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$2.
            Node v$g$2 = yyOpValue1;

            yyBase   = yyOption1;
            yyResult = pSym(yyBase);
            if (yyResult.hasValue(")")) {

              yyResult = pFunction$$Star1(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Pair<Node> v$g$3 = yyResult.semanticValue();

                yyBase   = yyResult.index;
                yyResult = pWord(yyBase);
                if (yyResult.hasValue("end")) {

                  yyValue = GNode.create("Function", v$g$1, v$g$2, v$g$3);

                  return yyResult.createValue(yyValue, yyError);
                } else {
                  yyError = yyError.select("'end' expected", yyBase);
                }
              }
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          } // End scope for v$g$2.
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }

        // Nested alternative 2.

        yyResult = pFunction$$Star2(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$g$5 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pWord(yyBase);
          if (yyResult.hasValue("end")) {

            yyValue = GNode.create("Function", v$g$1, null, v$g$5);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("'end' expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("function expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Function$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunction$$Star1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fFunction$$Star1) 
      yyColumn.chunk1.fFunction$$Star1 = pFunction$$Star1$1(yyStart);
    return yyColumn.chunk1.fFunction$$Star1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.Function$$Star1. */
  private Result pFunction$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$2 = yyResult.semanticValue();

      yyResult = pFunction$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$3 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Function$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunction$$Star2(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fFunction$$Star2) 
      yyColumn.chunk1.fFunction$$Star2 = pFunction$$Star2$1(yyStart);
    return yyColumn.chunk1.fFunction$$Star2;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.Function$$Star2. */
  private Result pFunction$$Star2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$4 = yyResult.semanticValue();

      yyResult = pFunction$$Star2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$5 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$4, v$5);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Identifiers.Sym.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSym(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSym) yyColumn.chunk1.fSym = pSym$1(yyStart);
    return yyColumn.chunk1.fSym;
  }

  /** Actually parse waebric.java.rats.parser.Identifiers.Sym. */
  private Result pSym$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymChar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Identifiers.SymChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '#':
      case '$':
      case '%':
      case '&':
      case '(':
      case ')':
      case '+':
      case ',':
      case '.':
      case ':':
      case ';':
      case '=':
      case '?':
      case '@':
      case '[':
      case ']':
      case '{':
      case '|':
      case '}':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("sym char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Identifiers.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdentifier) 
      yyColumn.chunk1.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.chunk1.fIdentifier;
  }

  /** Actually parse waebric.java.rats.parser.Identifiers.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (!contains(RESERVED, toText(yyValue))) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Identifiers.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWord(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fWord) 
      yyColumn.chunk1.fWord = pWord$1(yyStart);
    return yyColumn.chunk1.fWord;
  }

  /** Actually parse waebric.java.rats.parser.Identifiers.Word. */
  private Result pWord$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWordCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Identifiers.WordCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWordCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            if (('-' == yyC) ||
                (('0' <= yyC) && (yyC <= '9')) ||
                (('A' <= yyC) && (yyC <= 'Z')) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("word characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Strings.String.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pString(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyResult = pEscapeSequence(yyChoice1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }

        // Nested alternative 2.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\"':
          case '\\':
            /* No match. */
            break;

          default:
            {
              yyRepetition1 = yyIndex;
              continue;
            }
          }
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('\"' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Strings.EscapeSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscapeSequence(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fEscapeSequence) 
      yyColumn.chunk1.fEscapeSequence = pEscapeSequence$1(yyStart);
    return yyColumn.chunk1.fEscapeSequence;
  }

  /** Actually parse waebric.java.rats.parser.Strings.EscapeSequence. */
  private Result pEscapeSequence$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case 'n':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case 't':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case 'r':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case '\\':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case '\"':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                {
                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                      {
                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }

                    default:
                      /* No match. */
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select("escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Text.Text.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pText(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Node         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pTextChar(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$g$1.
        Pair<String> v$g$1 = yyRepValue1.reverse();

        yyC = character(yyRepetition1);
        if ('\"' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = GNode.create("Text", v$g$1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("text expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Text.TextChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTextChar(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTextChar) 
      yyColumn.chunk1.fTextChar = pTextChar$1(yyStart);
    return yyColumn.chunk1.fTextChar;
  }

  /** Actually parse waebric.java.rats.parser.Text.TextChar. */
  private Result pTextChar$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEscapeSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '&':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('#' == yyC) {
            yyIndex = yyChoice1 + 1;

            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('x' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyResult = pTextChar$$Plus1(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyC = character(yyResult.index);
                if (';' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyValue = difference(yyStart, yyIndex);

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }

            // Nested alternative 2.

            yyResult = pTextChar$$Plus2(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyC = character(yyResult.index);
              if (';' == yyC) {
                yyIndex = yyResult.index + 1;

                yyValue = difference(yyStart, yyIndex);

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ((':' == yyC) ||
                (('A' <= yyC) && (yyC <= 'Z')) ||
                ('_' == yyC) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyResult = pTextChar$$Star1(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyC = character(yyResult.index);
                if (';' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyValue = difference(yyStart, yyIndex);

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }

          // Nested alternative 3.

          yyPredMatched = false;

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            if (('#' == yyC) ||
                (('0' <= yyC) && (yyC <= ':')) ||
                (('A' <= yyC) && (yyC <= 'Z')) ||
                ('_' == yyC) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyPredMatched = true;
            }
          }

          if (! yyPredMatched) {

            yyValue = "&";

            return new SemanticValue(yyValue, yyChoice1, yyError);
          } else {
            yyError = yyError.select("text char expected", yyStart);
          }
        }
        break;

      case '\t':
      case '\n':
      case '\r':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
      case '&':
      case '<':
      case '\\':
        /* No match. */
        break;

      default:
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("text char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.TextChar$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTextChar$$Plus1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTextChar$$Plus1) 
      yyColumn.chunk2.fTextChar$$Plus1 = pTextChar$$Plus1$1(yyStart);
    return yyColumn.chunk2.fTextChar$$Plus1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.TextChar$$Plus1. */
  private Result pTextChar$$Plus1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pTextChar$$Plus1(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("text char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.TextChar$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTextChar$$Plus2(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTextChar$$Plus2) 
      yyColumn.chunk2.fTextChar$$Plus2 = pTextChar$$Plus2$1(yyStart);
    return yyColumn.chunk2.fTextChar$$Plus2;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.TextChar$$Plus2. */
  private Result pTextChar$$Plus2$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pTextChar$$Plus2(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("text char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.TextChar$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTextChar$$Star1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTextChar$$Star1) 
      yyColumn.chunk2.fTextChar$$Star1 = pTextChar$$Star1$1(yyStart);
    return yyColumn.chunk2.fTextChar$$Star1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.TextChar$$Star1. */
  private Result pTextChar$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('-' <= yyC) && (yyC <= '.')) ||
          (('0' <= yyC) && (yyC <= ':')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pTextChar$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fExpression) 
      yyColumn.chunk2.fExpression = pExpression$1(yyStart);
    return yyColumn.chunk2.fExpression;
  }

  /** Actually parse waebric.java.rats.parser.Expressions.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Post>.

    yyResult = pPostfix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, v$g$3);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Expression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$$Tail1(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Add>.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue("+")) {

      yyResult = pPostfix(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("AddExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Postfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfix(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPostfix) 
      yyColumn.chunk2.fPostfix = pPostfix$1(yyStart);
    return yyColumn.chunk2.fPostfix;
  }

  /** Actually parse waebric.java.rats.parser.Expressions.Postfix. */
  private Result pPostfix$1(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Primary>.

    yyResult = pPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pPostfix$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, v$g$3);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Postfix$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfix$$Tail1(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Field>.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue(".")) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("FieldExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("postfix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Primary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimary(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Primary", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Primary", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pRecord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Primary", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pVar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      yyValue = GNode.create("Primary", v$g$4);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Var.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVar(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Var", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Constant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("Constant", v$g$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pNumber(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Constant", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Record.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRecord(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Pair<Node> yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue("{")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pPairs(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        Pair<Node> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        Pair<Node> v$g$1 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue("}")) {

          yyValue = GNode.create("Record", v$g$1);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("record expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.List.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Pair<Node> yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue("[")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pExpressions(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        Pair<Node> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        Pair<Node> v$g$1 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = GNode.create("List", v$g$1);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Expressions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressions(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$l$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$l$2.
        Pair<Node> v$l$2 = yyRepValue1.reverse();

        yyValue = new Pair<Node>(v$l$1, v$l$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$l$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Pair.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPair(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPair) 
      yyColumn.chunk2.fPair = pPair$1(yyStart);
    return yyColumn.chunk2.fPair;
  }

  /** Actually parse waebric.java.rats.parser.Expressions.Pair. */
  private Result pPair$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSym(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("Pair", v$g$1, v$g$2);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Expressions.Pairs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPairs(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPair(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$l$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pPair(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$l$2.
        Pair<Node> v$l$2 = yyRepValue1.reverse();

        yyValue = new Pair<Node>(v$l$1, v$l$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$l$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Predicates.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    if (yyResult.hasValue("list")) {
      yyValue = "list";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIdentifier(yyStart);
    if (yyResult.hasValue("record")) {
      yyValue = "record";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pIdentifier(yyStart);
    if (yyResult.hasValue("string")) {
      yyValue = "string";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Predicates.Predicate.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPredicate(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Unary>.

    yyResult = pUnary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pPredicate$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Action<Node> v$5 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$5, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$6.
        Pair<Action<Node>> v$6 = yyRepValue1.reverse();

        yyValue = apply(v$6, v$g$4);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$6.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Predicate$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPredicate$$Tail1(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue("&&")) {

      yyResult = pUnary(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("AndPredicate", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue("||")) {

      yyResult = pUnary(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("OrPredicate", v$1, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("predicate expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Predicates.Unary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnary(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fUnary) 
      yyColumn.chunk2.fUnary = pUnary$1(yyStart);
    return yyColumn.chunk2.fUnary;
  }

  /** Actually parse waebric.java.rats.parser.Predicates.Unary. */
  private Result pUnary$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pUnary(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("Unary", v$g$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pCondition(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Unary", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Predicates.Condition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCondition(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPostfix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyC = character(yyResult.index);
      if ('.' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pType(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$g$2 = yyResult.semanticValue();

          yyC = character(yyResult.index);
          if ('?' == yyC) {
            yyIndex = yyResult.index + 1;

            yyValue = GNode.create("Condition", v$g$1, v$g$2);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Condition", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("condition expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Markup.Arguments.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArguments(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArgument(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$l$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pArgument(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$l$2.
        Pair<Node> v$l$2 = yyRepValue1.reverse();

        yyValue = new Pair<Node>(v$l$1, v$l$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$l$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Markup.Argument.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgument(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fArgument) 
      yyColumn.chunk2.fArgument = pArgument$1(yyStart);
    return yyColumn.chunk2.fArgument;
  }

  /** Actually parse waebric.java.rats.parser.Markup.Argument. */
  private Result pArgument$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSym(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("Argument", v$g$1, v$g$2);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Argument", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Markup.Markup.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMarkup(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fMarkup) 
      yyColumn.chunk2.fMarkup = pMarkup$1(yyStart);
    return yyColumn.chunk2.fMarkup;
  }

  /** Actually parse waebric.java.rats.parser.Markup.Markup. */
  private Result pMarkup$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Pair<Node> yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDesignator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSym(yyBase);
      if (yyResult.hasValue("(")) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pArguments(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          Pair<Node> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          Pair<Node> v$g$2 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSym(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("Markup", v$g$1, v$g$2);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$g$2.
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = GNode.create("Markup", v$g$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Markup.Designator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDesignator(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pAttribute(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$g$2.
        Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.create("Designator", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Markup.Attribute.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttribute(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue("#")) {
      String v$g$1 = "#";

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("Attribute", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue(".")) {
      String v$g$3 = ".";

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("Attribute", v$g$3, v$g$4);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue("$")) {
      String v$g$5 = "$";

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$6 = yyResult.semanticValue();

        yyValue = GNode.create("Attribute", v$g$5, v$g$6);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue(":")) {
      String v$g$7 = ":";

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$8 = yyResult.semanticValue();

        yyValue = GNode.create("Attribute", v$g$7, v$g$8);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 5.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue("@")) {
      String v$g$9 = "@";

      yyResult = pNumber(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$10 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase   = yyChoice1;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue("%")) {
          String v$g$11 = "%";

          yyResult = pNumber(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$12 = yyResult.semanticValue();

            yyValue = GNode.create("Attribute", v$g$9, v$g$10, v$g$11, v$g$12);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'%' expected", yyBase);
        }

        // Nested alternative 2.

        yyValue = GNode.create("Attribute", v$g$9, v$g$10);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("attribute expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatement) 
      yyColumn.chunk2.fStatement = pStatement$1(yyStart);
    return yyColumn.chunk2.fStatement;
  }

  /** Actually parse waebric.java.rats.parser.Statements.Statement. */
  private Result pStatement$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIf(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Statement", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEach(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Statement", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pLet(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Statement", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      yyValue = GNode.create("Statement", v$g$4);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pEcho(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$5 = yyResult.semanticValue();

      yyValue = GNode.create("Statement", v$g$5);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pCData(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$6 = yyResult.semanticValue();

      yyValue = GNode.create("Statement", v$g$6);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pYield(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$7 = yyResult.semanticValue();

      yyValue = GNode.create("Statement", v$g$7);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$8 = yyResult.semanticValue();

      yyValue = GNode.create("Statement", v$g$8);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pCall(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$9 = yyResult.semanticValue();

      yyValue = GNode.create("Statement", v$g$9);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.If.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIf(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("if")) {

      yyBase   = yyResult.index;
      yyResult = pSym(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pPredicate(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSym(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pStatement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$2 = yyResult.semanticValue();

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyBase   = yyChoice1;
              yyResult = pWord(yyBase);
              if (yyResult.hasValue("else")) {

                yyResult = pStatement(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$g$3 = yyResult.semanticValue();

                  yyValue = GNode.create("If", v$g$1, v$g$2, v$g$3);

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("'else' expected", yyBase);
              }

              // Nested alternative 2.

              yyValue = GNode.create("If", v$g$1, v$g$2, null);

              return new SemanticValue(yyValue, yyChoice1, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("if expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Each.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEach(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("each")) {

      yyBase   = yyResult.index;
      yyResult = pSym(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pPair(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSym(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pStatement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("Each", v$g$1, v$g$2);

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("each expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Let.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLet(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("let")) {

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBinding(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Node> v$g$1 = yyRepValue1.reverse();

        yyBase   = yyRepetition1;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("in")) {

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pStatement(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              Node v$el$2 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$g$2.
            Pair<Node> v$g$2 = yyRepValue1.reverse();

            yyBase   = yyRepetition1;
            yyResult = pWord(yyBase);
            if (yyResult.hasValue("end")) {

              yyValue = GNode.create("Let", v$g$1, v$g$2);

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("'end' expected", yyBase);
            }
          } // End scope for v$g$2.
        } else {
          yyError = yyError.select("'in' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("let expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Comment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComment(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("comment")) {

      yyResult = pString(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("Comment", v$g$1);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Echo.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEcho(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("echo")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("Echo", v$g$1);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }

      // Nested alternative 2.

      yyResult = pEmbedding(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("Echo", v$g$2);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("echo expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.CData.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCData(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("cdata")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("CData", v$g$1);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("c data expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Yield.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pYield(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("yield")) {

      yyBase   = yyResult.index;
      yyResult = pSym(yyBase);
      if (yyResult.hasValue(";")) {

        yyValue = GNode.create("Yield", false);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("yield expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Block.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlock(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue("{")) {

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pStatement(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$g$1.
        Pair<Node> v$g$1 = yyRepValue1.reverse();

        yyBase   = yyRepetition1;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue("}")) {

          yyValue = GNode.create("Block", v$g$1);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("block expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Call.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCall(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMarkup(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSym(yyBase);
      if (yyResult.hasValue(";")) {

        yyValue = GNode.create("Call", null, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pMarkups(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$3 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$4 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("Call", v$g$3, v$g$4);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }

      // Nested alternative 2.

      yyResult = pMarkup(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$5 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("Call", v$g$3, v$g$5);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }

      // Nested alternative 3.

      yyResult = pStatement(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$6 = yyResult.semanticValue();

        yyValue = GNode.create("Call", v$g$3, v$g$6);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Markups.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMarkups(final int yyStart) throws IOException {
    int        yyC;
    Result     yyResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pMarkup(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyPredMatched = false;

        yyC = character(yyResult.index);
        if (';' == yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        } else {
          yyError = yyError.select("markups expected", yyStart);
        }
      }
      break;
    }

    if (yyRepeated1) {
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Binding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBinding(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSym(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSym(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = GNode.create("Binding", v$g$1, v$g$2);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSym(yyBase);
      if (yyResult.hasValue("(")) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pFormals(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$3.
          Node v$g$3 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSym(yyBase);
          if (yyResult.hasValue(")")) {

            yyBase   = yyResult.index;
            yyResult = pSym(yyBase);
            if (yyResult.hasValue("=")) {

              yyResult = pStatement(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$4 = yyResult.semanticValue();

                yyValue = GNode.create("Binding", v$g$1, v$g$3, v$g$4);

                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("'=' expected", yyBase);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$g$3.
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Statements.Formals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormals(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fFormals) 
      yyColumn.chunk3.fFormals = pFormals$1(yyStart);
    return yyColumn.chunk3.fFormals;
  }

  /** Actually parse waebric.java.rats.parser.Statements.Formals. */
  private Result pFormals$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyResult = pFormals$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("Formals", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Formals$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormals$$Star1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fFormals$$Star1) 
      yyColumn.chunk3.fFormals$$Star1 = pFormals$$Star1$1(yyStart);
    return yyColumn.chunk3.fFormals$$Star1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.Formals$$Star1. */
  private Result pFormals$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSym(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyResult = pFormals$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<String> v$2 = yyResult.semanticValue();

          yyValue = new Pair<String>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.Site.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSite(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSite) 
      yyColumn.chunk3.fSite = pSite$1(yyStart);
    return yyColumn.chunk3.fSite;
  }

  /** Actually parse waebric.java.rats.parser.Sites.Site. */
  private Result pSite$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Pair<Node> yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("site")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pMappings(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        Pair<Node> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        Pair<Node> v$g$1 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("end")) {

          yyValue = GNode.create("Site", v$g$1);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'end' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("site expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.Mapping.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMapping(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMapping) 
      yyColumn.chunk3.fMapping = pMapping$1(yyStart);
    return yyColumn.chunk3.fMapping;
  }

  /** Actually parse waebric.java.rats.parser.Sites.Mapping. */
  private Result pMapping$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDir(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSym(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pMarkup(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("Mapping", v$g$1, v$g$2);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.Mappings.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMappings(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMapping(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$l$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSym(yyBase);
        if (yyResult.hasValue(";")) {

          yyResult = pMapping(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$l$2.
        Pair<Node> v$l$2 = yyRepValue1.reverse();

        yyValue = new Pair<Node>(v$l$1, v$l$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$l$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.Elt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElt(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fElt) yyColumn.chunk3.fElt = pElt$1(yyStart);
    return yyColumn.chunk3.fElt;
  }

  /** Actually parse waebric.java.rats.parser.Sites.Elt. */
  private Result pElt$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\t':
      case '\n':
      case '\r':
      case ' ':
      case '/':
      case ':':
      case '\\':
        /* No match. */
        break;

      default:
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pElt(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("elt expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Sites.Dir.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDir(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pElt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      while (true) {

        yyC = character(yyRepetition1);
        if ('/' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyResult = pElt(yyIndex);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            continue;
          }
        }
        break;
      }

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    while (true) {

      yyC = character(yyRepetition1);
      if ('/' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyResult = pElt(yyIndex);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Layout.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '/':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;

              switch (yyC) {
              case '*':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    final int yyChoice2 = yyRepetition2;

                    // Nested alternative 1.

                    yyC = character(yyChoice2);
                    if (-1 != yyC) {
                      yyIndex = yyChoice2 + 1;

                      switch (yyC) {
                      case '*':
                        {
                          yyPredMatched = false;

                          yyC = character(yyIndex);
                          if ('/' == yyC) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyRepetition2 = yyIndex;
                            continue;
                          } else {
                            yyError = yyError.select("spacing expected", yyStart);
                          }
                        }
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  yyBase = yyRepetition2;
                  yyC    = character(yyBase);
                  if ('*' == yyC) {
                    yyIndex = yyRepetition2 + 1;

                    yyC = character(yyIndex);
                    if ('/' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyRepetition1 = yyIndex;
                      continue;
                    } else {
                      yyError = yyError.select("'*/' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'*/' expected", yyBase);
                  }
                }
                break;

              case '/':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    yyC = character(yyRepetition2);
                    if (-1 != yyC) {
                      yyIndex = yyRepetition2 + 1;

                      switch (yyC) {
                      case '\n':
                      case '\r':
                        /* No match. */
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  yyPredResult = pLineTerminator(yyRepetition2);
                  yyError      = yyPredResult.select(yyError);
                  if (yyPredResult.hasValue()) {

                    yyRepetition1 = yyRepetition2;
                    continue;
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Layout.LineTerminator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineTerminator(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("line terminator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Numbers.Number.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumber(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fNumber) 
      yyColumn.chunk3.fNumber = pNumber$1(yyStart);
    return yyColumn.chunk3.fNumber;
  }

  /** Actually parse waebric.java.rats.parser.Numbers.Number. */
  private Result pNumber$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDigits(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("Number", v$g$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Numbers.Digits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Embedding.PreText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreText(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyResult = pTextChar(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('<' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("pre text expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Embedding.PostText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostText(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyResult = pTextChar(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('\"' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("post text expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Embedding.MidText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMidText(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyResult = pTextChar(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('<' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("mid text expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Embedding.TextTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTextTail(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fTextTail) 
      yyColumn.chunk3.fTextTail = pTextTail$1(yyStart);
    return yyColumn.chunk3.fTextTail;
  }

  /** Actually parse waebric.java.rats.parser.Embedding.TextTail. */
  private Result pTextTail$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPostText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("TextTail", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMidText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$2 = yyResult.semanticValue();

      yyResult = pEmbed(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$3 = yyResult.semanticValue();

        yyResult = pTextTail(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$4 = yyResult.semanticValue();

          yyValue = GNode.create("TextTail", v$g$2, v$g$3, v$g$4);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Embedding.Embedding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEmbedding(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPreText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyResult = pEmbed(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyResult = pTextTail(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("Embedding", v$g$1, v$g$2, v$g$3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal waebric.java.rats.parser.Embedding.Embed.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEmbed(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fEmbed) 
      yyColumn.chunk3.fEmbed = pEmbed$1(yyStart);
    return yyColumn.chunk3.fEmbed;
  }

  /** Actually parse waebric.java.rats.parser.Embedding.Embed. */
  private Result pEmbed$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Embed", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEmbed$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$2 = yyResult.semanticValue();

      yyResult = pMarkup(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("Embed", v$g$2, v$g$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * waebric.java.rats.parser.Waebric.Embed$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEmbed$$Plus1(final int yyStart) throws IOException {
    WaebricColumn yyColumn = (WaebricColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fEmbed$$Plus1) 
      yyColumn.chunk3.fEmbed$$Plus1 = pEmbed$$Plus1$1(yyStart);
    return yyColumn.chunk3.fEmbed$$Plus1;
  }

  /** Actually parse waebric.java.rats.parser.Waebric.Embed$$Plus1. */
  private Result pEmbed$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMarkup(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pEmbed$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Node>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  static {
    add(RESERVED, new String[] {
      "module",
      "site",
      "import",
      "def",
      "end",
      "if",
      "else",
      "each",
      "echo",
      "comment",
      "let",
      "in",
      "yield",
      "cdata"
    });
  }

  // =========================================================================

  /**
   * Get the specified text.
   *
   * @param s The text.
   * @return The text.
   */
  protected static final String toText(String s) {
    return s;
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
