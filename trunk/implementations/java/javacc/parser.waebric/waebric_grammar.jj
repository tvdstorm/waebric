/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\waebric_grammar.jj */
/*@egen*/options {
  JDK_VERSION = "1.5";
} 

PARSER_BEGIN(WaebricParser) 

public class WaebricParser/*@bgen(jjtree)*/implements WaebricParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTWaebricParserState jjtree = new JJTWaebricParserState();

/*@egen*/
  public static void main(String args[]) {
    System.out.println("Reading from standard input...");
    System.out.print("Enter a Waebric FunctionDef :");
    new WaebricParser(System.in);
    try {
      SimpleNode n = WaebricParser.Modules();
      n.dump("");
      System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }
  }
}
PARSER_END(WaebricParser)

/* LAYOUT */
<*>
SKIP : {
	" "
	| "\t"
	| "\n"
	| "\r"
	| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
	| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

/* RESERVED KEYWORDS */
<DEFAULT, IN_NO_MODULEID, IN_PATH>
TOKEN : {
	< MODULE : "module" >
	|	< IMPORT : "import" >
	|	< SITE : "site" > : IN_PATH
	|	< END : "end" > : DEFAULT
	|	< DEF : "def" > : IN_NO_MODULEID
	|	< IF : "if" >
	|	< ELSE : "else" >
	|	< EACH : "each" >
	|	< LET : "let" >
	|	< IN : "in" >
	|	< YIELD : "yield" >
	|	< COMMENT : "comment" > : IN_STRCON
	|	< ECHO : "echo" >
	|	< CDATA : "cdata" >
	|	< #LIST : "list" >
	|	< #RECORD : "record" >
	|	< #STRING : "string" >
}

/* SEPARATORS */
<DEFAULT, IN_NO_MODULEID>
TOKEN : {
	< LPAREN : "(" > 
	|	< RPAREN : ")" > 
	|	< LBRACKET : "[" >
	|	< RBRACKET : "]" >
	|	< LBRACE : "{" >
	|	< RBRACE : "}" >
	|	< SEMICOLON : ";" >
	|	< COLON : ":" >
	|	< COMMA : "," >
	|	< DOT : "." >
}

/* OPERATORS */
<IN_NO_MODULEID>
TOKEN : {
	< DOLLAR_SIGN: "$" >
	|	< NUMBER_SIGN: "#" >
	|	< ASSIGN : "=" >
	|	< AT : "@" >
	|	< QUESTIONMARK: "?" >
	|	< EXCLAMATION: "!" >
	|	< PERCENT : "%" >
}

/* START NORMAL TOKENS */
<DEFAULT>
TOKEN : {
	< ModuleId :
		(< IdCon > (< DOT >)?)+
	>	
}

<IN_PATH>
TOKEN : {
	< #PathElement :
		(~[" ","\t","\n","\r",".","/","\\"])+
	>	
}

<IN_PATH>
TOKEN : {
	< FileName :
		<PathElement> <DOT> <FileExt>
	> : IN_NO_MODULEID
} 

<IN_PATH>
TOKEN : {
	< #FileExt :
		(["a"-"z","A"-"Z","0"-"9"])+
	>
}

<IN_PATH>
TOKEN : {
	< DirName :
		<Directory>
	>	
}

<IN_PATH>
TOKEN : {
	< #Directory :
		(<PathElement> "/")+
	>	
}

<IN_NO_MODULEID>
TOKEN : {
	< IdCon :
		["A"-"Z","a"-"z"](["A"-"Z","a"-"z","-","0"-"9"])* 
	> 
}

<IN_NO_MODULEID>
TOKEN : {
	< NatCon : (["0"-"9"])+ >
}

<IN_NO_MODULEID>
TOKEN : {   
 	< SymbolCon : 
 		["'"] (<SymbolChar>)* 
 	>
}

<IN_NO_IDCON>
TOKEN : {
    < #SymbolChar : 
    	~["\0"-"\37",")"," ","\t","\n","\r",";",",",">","\177"-"\377"] // Octale getallen
    >
}

<IN_NO_MODULEID>
TOKEN : {
	< Text : 
		["\""] (<TextChar>)* ["\""] 
	>
}

<IN_NO_MODULEID>
TOKEN : {
    < #TextChar : 
    	<TextCharRef> 
    	|	<EscQuote>
    	|	<Amp>
    	|	<TextEntityRef>
    	|	~["\0"-"\37","&","\"","<","\200"-"\377"] | ["\n","\r","\t"] 
    >
}

<IN_NO_MODULEID>
TOKEN : {
    < #TextCharRef : 
    	"&#" (["0"-"9"])+ <SEMICOLON> | "&#x" (["0"-"9","a"-"f","A"-"F"])+ <SEMICOLON>
    >
}

<IN_NO_MODULEID>
TOKEN : {
   	< #EscQuote : 
   		["\\"]["\""]
   	> 
}

<IN_NO_MODULEID>
TOKEN : {
    < #Amp : 
    	["&"] 
    >
}

<IN_NO_MODULEID>
TOKEN : {
   	< #TextEntityRef : 
   		"&" ["a"-"z","A"-"Z","_",":"] (["a"-"z","A"-"Z","0"-"9",".","-","_",":"])* <SEMICOLON> 
   	>
} 

<IN_STRCON>
TOKEN : {
	< StrCon :
		"\"" (< StrChar >)* "\""
	> : IN_NO_IDCON
}

<IN_NO_MODULEID>
TOKEN : {
	< #StrChar :
		"\n"
		|	"\t"
		|	"\\"
		|	"\\\\"
		|	"\\" (["0"-"9"]){3}
		|	~["\0"-"\37","\n","\t","\"","\\"]
	>
}
<IN_NO_MODULEID>
TOKEN : {
	< Type :
		<LIST>
		|	<RECORD>
		|	<STRING>
	>
}

// Embedding
<IN_NO_MODULEID>
TOKEN : {
	< PreText :
		"\"" (<TextChar>)* "<"
	>
}

<IN_NO_MODULEID>
TOKEN : {
	< PostText :
		">" (<TextChar>)* "\""
	>	
}

<IN_NO_MODULEID>
TOKEN : {
	< MidText :
		">" (<TextChar>)* "<"
	>	
}

/* GENERIC */
SimpleNode Modules():{/*@bgen(jjtree) Modules */
  SimpleNode jjtn000 = new SimpleNode(JJTMODULES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modules */
  try {
/*@egen*/
  (Module())* ";"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Module() : {/*@bgen(jjtree) Module */
  SimpleNode jjtn000 = new SimpleNode(JJTMODULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Module */
        try {
/*@egen*/
	< MODULE > < ModuleId > (ModuleElement())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void ModuleElement() : {/*@bgen(jjtree) ModuleElement */
  SimpleNode jjtn000 = new SimpleNode(JJTMODULEELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ModuleElement */
        try {
/*@egen*/
	Import()
	|	Site()
	|	FunctionDef()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// ModuleElement Import 
// *********************************************
void Import() : {/*@bgen(jjtree) Import */
  SimpleNode jjtn000 = new SimpleNode(JJTIMPORT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Import */
        try {
/*@egen*/ 
	< IMPORT > < ModuleId >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
} 

// ModuleElement Site
// *********************************************
void Site() : {/*@bgen(jjtree) Site */
  SimpleNode jjtn000 = new SimpleNode(JJTSITE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Site */
        try {
/*@egen*/
	< SITE > Mappings() < END >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Mappings() : {/*@bgen(jjtree) Mappings */
  SimpleNode jjtn000 = new SimpleNode(JJTMAPPINGS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Mappings */
        try {
/*@egen*/
	(Mapping() (<SEMICOLON>)?)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Mapping() : {/*@bgen(jjtree) Mapping */
  SimpleNode jjtn000 = new SimpleNode(JJTMAPPING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Mapping */
        try {
/*@egen*/
	Path() <COLON> Markup()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Path() : {/*@bgen(jjtree) Path */
  SimpleNode jjtn000 = new SimpleNode(JJTPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Path */
        try {
/*@egen*/
	<FileName>
	|	<DirName> <FileName>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

// ModuleElement FunctionDef
// *********************************************
void FunctionDef(): {/*@bgen(jjtree) FunctionDef */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) FunctionDef */
        try {
/*@egen*/
	<DEF> <IdCon> (Formals())? (Statement())* <END>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Formals() : {/*@bgen(jjtree) Formals */
  SimpleNode jjtn000 = new SimpleNode(JJTFORMALS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Formals */
        try {
/*@egen*/
	<LPAREN> (<IdCon> (<COMMA>)?)* <RPAREN>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Statement() : {/*@bgen(jjtree) Statement */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Statement */
        try {
/*@egen*/
	LOOKAHEAD(8)(<IF> <LPAREN> Predicate() <RPAREN> Statement()) <ELSE> Statement()
	//|	LOOKAHEAD(2)((Markup())+ <SEMICOLON>)
	|	<IF> <LPAREN> Predicate()<RPAREN> Statement()
	|	<EACH> <LPAREN> Var() <COLON> Expression() (DotIdCon())? <RPAREN> Statement()
	|	<LET> (Assignment())+ <IN> (Statement())* "end"	
	|	(<LBRACE> (Statement())* <RBRACE>)
	|	<YIELD> <SEMICOLON>
	|	<COMMENT> <StrCon> <SEMICOLON>
	|	<ECHO> Expression() (DotIdCon())? <SEMICOLON>
	|	<CDATA> Expression() (DotIdCon())? <SEMICOLON>
	|   (Markup())+ (<SEMICOLON> 
		|	(Statement()) 
		|	(Expression()(DotIdCon())? <SEMICOLON>) 
		|	(Embedding() <SEMICOLON>))/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Predicate() : {/*@bgen(jjtree) Predicate */
  SimpleNode jjtn000 = new SimpleNode(JJTPREDICATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Predicate */
        try {
/*@egen*/
	LOOKAHEAD(2) Expression() (DotIdCon())?
	|	LOOKAHEAD(Expression() (DotIdCon())?)<DOT> <Type>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Assignment() : {/*@bgen(jjtree) Assignment */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Assignment */
        try {
/*@egen*/
	<IdCon> Formals() <ASSIGN> Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Embedding() : {/*@bgen(jjtree) Embedding */
  SimpleNode jjtn000 = new SimpleNode(JJTEMBEDDING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Embedding */
        try {
/*@egen*/
	<PreText> Embed() TextTail()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void Embed() : {/*@bgen(jjtree) Embed */
  SimpleNode jjtn000 = new SimpleNode(JJTEMBED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Embed */
        try {
/*@egen*/ 
	(Markup())* Expression()(DotIdCon())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TextTail() : {/*@bgen(jjtree) TextTail */
  SimpleNode jjtn000 = new SimpleNode(JJTTEXTTAIL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) TextTail */
        try {
/*@egen*/ 
	<PostText>
	|	<MidText> Embed() TextTail()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// Used by both the Site and FunctionDef ModuleElements
// *********************************************
void Markup() : {/*@bgen(jjtree) Markup */
  SimpleNode jjtn000 = new SimpleNode(JJTMARKUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Markup */
        try {
/*@egen*/ 
	Designator() (Arguments())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Designator() : {/*@bgen(jjtree) Designator */
  SimpleNode jjtn000 = new SimpleNode(JJTDESIGNATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Designator */
        try {
/*@egen*/
	<IdCon> (Attribute())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void Attribute() : {/*@bgen(jjtree) Attribute */
  SimpleNode jjtn000 = new SimpleNode(JJTATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Attribute */
        try {
/*@egen*/
	<NUMBER_SIGN> <IdCon>
	|	<DOT> <IdCon>
	|	<DOLLAR_SIGN> <IdCon>
	|	<COLON> <IdCon>
	| 	LOOKAHEAD(2) <AT> <NatCon> <PERCENT> <NatCon>
	| 	<AT> <NatCon>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Arguments() : {/*@bgen(jjtree) Arguments */
  SimpleNode jjtn000 = new SimpleNode(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Arguments */
        try {
/*@egen*/
	<LPAREN> (Argument() (<COMMA>)?)* <RPAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Argument() : {/*@bgen(jjtree) Argument */
  SimpleNode jjtn000 = new SimpleNode(JJTARGUMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Argument */
        try {
/*@egen*/
	LOOKAHEAD(2)Var() <ASSIGN> Expression() (DotIdCon())?
	|	Expression() (DotIdCon())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Var() : {/*@bgen(jjtree) Var */
  SimpleNode jjtn000 = new SimpleNode(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Var */
        try {
/*@egen*/
	<IdCon>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Expression() : {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	// DotIdCon staat verspreid voor alle aanroepen van Expression
	// Toevoegen hier werkt niet, overal achter expression werkt wel.
	<SymbolCon> 
	|	<Text>
	|	<NatCon>
	|	Var()
	|	<LBRACKET> (Expression() (DotIdCon())? (<COMMA>)? )* <RBRACKET>
	|	<LBRACE> (KeyValuePair()  (<COMMA>)? )* <RBRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DotIdCon() : {/*@bgen(jjtree) DotIdCon */
  SimpleNode jjtn000 = new SimpleNode(JJTDOTIDCON);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) DotIdCon */
        try {
/*@egen*/
	<DOT> <IdCon>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void KeyValuePair() : {/*@bgen(jjtree) KeyValuePair */
  SimpleNode jjtn000 = new SimpleNode(JJTKEYVALUEPAIR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) KeyValuePair */
        try {
/*@egen*/
	<IdCon> <COLON> Expression() (DotIdCon())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* TESTCODE
module myhome.html
import homepage

module myhome2
import homepage2

site
end

module myhome3a
import homepage4

site
	index.html: home
end

module myhome3
import homepage4

def home(msg)
layout(msg); echo msg;
end

site
	index.html: home#A121
end

site
	index.html: home@2121%2112
end

site
	roflcopter/index2.html:  vla()
end

module myhome3
site 
	index1.html: vla.test(
		'387,
		9832, 
		{ hallo:4983 }, 
		A=9382, 
		'372, 
		"text",
		[32,43,32,23],
		["a","v"])
end

def menu(menu)
  echo menu.title;
  ul each (kid: menu.kids)
  menuitem(kid);
end

def
  testme()

  html {
	body yield;	
	head title title;
	grap;
	wat heb je hier nou aan;
	test yield;
  }
end

module homepage

site
  index.html: home("Hello World!")
end

module homepage

def menu(menu)
  echo menu.title;
  ul each (kid: menu.kids)
  menuitem(kid);
end

def home(msg)
  layout single-column { 
  head title msg;
  body echo msg;
  }
end

module myhome.html

 def menu(menu)
  echo menu.title;
  ul each (kid: menu.kids)
  menuitem(kid);
end

def menuitem(item)
  if (item.kids)
  li menu(item);
else
  li a(href=item.link) item.title;
end

Voorbeelden die WEL parsable zijn:
waebric.pdf voorbeelden
abon.wae
kopij.wae
lava.wae
over.wae
menus.wae

Voorbeelden die NIET parsable zijn
brand.wae
home.wae
-> Found pretext error
utils.wae
-> Exception in thread "main" TokenMgrError: Lexical error at line 1, column 1089.  Encountered: ";" (59), after : ""
verhalen.wae
-> Encountered " <ModuleId> "p "" at line 1, column 1405.
ldta.wae
-> Exception in thread "main" TokenMgrError: Lexical error at line 1, column 176.  Encountered: "+" (43), after : ""
*/


